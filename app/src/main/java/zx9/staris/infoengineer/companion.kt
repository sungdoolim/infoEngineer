package zx9.staris.infoengineer

class companion(){

     companion object{
          var backKeyPressedTime: Long = 0
         var TitleList= arrayListOf(
             titleUrl(
                 "폭포수 : 전통적, 오래거림 , 각 단계 산출물이 명확\n프로토타입 : 최종 결과물 예측 모형\n나선형 : 여러 번의 개발 과정을 걸쳐 점진적으로 개발, 유지보수 필요 x,  보헴 이 제안\n - 계획->위험 분석->개발->고객평가 반복\n \n애자일 : 요구사항 변화에 유연하게 대응, 일정 주기를 반복, 폭포수와 대조적, \n-스크럼,xp,칸반,lean,FDD(기능 중심 개발) 등이 있음\n애자일 핵심 가치 :\n프로세스보다는 개인과 상호작용에 중점을 둔다 /\n문서보다는 sw에 집중 /\n계약보다는 협업 /\n계획 보다는 변화에 반응\n \n소프트 웨어 공학 : sw의 위기를 극복하기 위한 방안으로 연구된 학문\n \n \n n \n \n",
                 "소프트웨어 생명주기"
             ),

             titleUrl(
                 "스크럼 : 팀이 중심이 되어 개발의 효율성을 높이는 기법\n기원: 럭비경기 이야기 나옴\n \n제품 책임자 : PO : 백로그 작성 주체 , 제품에 대한 이해가 높음, 의사 결정에 중요한 역할\n스크럼 마스터 : 가이드 역할\n개발팀\n \n계획->스프린트 -> 스크럼 회의 -> 스프린트 검토 -> 회고\n \n계획 : 백로그 중 스프린트에서 수행할 작업 일정 수립\n스프린트 : 실제 개발 진행 과정, 약 2~4주\n스크럼 회의 : 매일 약 15분 진행,소멸차트 표시\n스프린트 검토 : 요구사항  테스팅\n스프린트 회고 : 규칙 준수 여부 및 개선 점 확인 기록\n \n \n \n \n  \n",
                 "스크럼 기법"
             ),

             titleUrl(
                 "고객 참여와 개발 과정의 반복\n릴리즈 기간을 짧게\n핵심 가치 : 의사소통,단순성,용기,존중,피드백\n릴리즈 계획 수립 -> 주기 -> 승인검사(인수 테스트) -> 소규모 릴리즈\n \n페어 프로그래밍/ 공동 코드 소유/ 테스트 주도 개발 / 전체 팀/ 계속적인 통합 / 리팩토링 / 소규모 릴리즈\n \n \n  \n",
                 "XP"
             ),

             titleUrl(
                 "1단계 : 시스템 구성/시스템 기능/ 시스템 인터페이스 파악\n2단계 : 아키텍처 구성/소프트웨어 구성 파악\n3단계 : 하드웨어 구성/ 네트워크 구성 파악\n \n라이센스 : 상용 sw의 경우 보유한 라이센스 파악이 중요\n \n  \n",
                 "현행 시스템 파악"
             ),

             titleUrl(
                 "미들웨어 : 운영체제가 제공하는 서비스 외 추가작 서비스를 제공하는 sw\n \n운영체제 : 컴퓨터 시스템 자원 관리, 컴퓨터를 편리하고 효율적으로 사용할 수 있는 환경을 제공하는 sw\n가용성,성능,기술지원,구축비용등 고려\n \ndbms : 사용자와 db사이에서 정보를 생성해 주고, db를 관리해 주는 sw / 파일 시스템의 종속성,중복성을 해결하기위해 제안됨\n가용성,성능,기술지원,구축비용,호환성 등 고려\n \nwas  : 웹 어플리케이션 서버 : 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어\n \n오픈소스 : 누구나 사용할 수 있도록 소스 코드를 공개한 sw\n - 라이선스,사용자 수, 기술 지속 가능성등을 고려해야함\n \n \n  \n",
                 "개발 기술 환경 파악"
             ),

             titleUrl(
                 "sw가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 제약조건\n기능,비기능,사용자,시스템 요구사항\n \n비기능 : 품질,제약사항\n사용자 : 사용자 관점에서 제공해야 할 요구사항, 친숙한 표현으로 작성\n시스템 : 개발자 관점에서 시스템 전체가 제공해야 할 요구 사항\n \n  \n",
                 "요구사항 정의"
             ),

             titleUrl(
                 "요구사항 도출 분석 후 명세처리 및 확인,검증 등의 활동\n \n타당성 조사 : 비즈니스 목적에 부합되는지 판단\n- 요구사항 개발 프로세스 이전에 수행된다\n \n도출 -> 분석 -> 명세 -> 확인\n \n도출 : 설문,브레인스토밍,프로토타이핑, 유스케이스\n \n분석 : 요구 사항 중 모호한 부분을 발견하고 걸러내기 위한 과정\n - 자료 흐름도(DFD), 자료 사전(DD)\n \n명세: 분석된 요구사항을 바탕으로 모델을 작성, 문서화\n-기능 요구사항은 빠짐 없이, 비기능은 필요한 것만\n-정형 명세 : 수학적 기호, 완전성 검증 가능, 표기가 어려움\n-비정형 명세 : 상태,객체 중심, 줄글이나 다이어그램으로 표기\n \n \n \n확인 :명세서 검토 , 형상 관리\n \n요구공학 : 요구사항을 정의하고, 분석,관리하는 프로세스를 연구하는 학문\n \n  \n \n",
                 "요구사항 개발 프로세스"
             ),

             titleUrl(
                 "사용자의 요구사항을 이해하고 문서화(명세화) 하는 활동 / 비용과 일정에 대한 제약 설정\n \n구조적 분석 기법 : 자료의 흐름과 처리를 중심으로 분석/ \n-자료 흐름도(DFD), 자료사전(DD), 소단위 명세서, 개체 관계도(ERD), 상태 전이도 (STD), 제어 명세서\n \n자료 흐름도 \n-도형 중심으로 기술하는 방법\n-프로세스 : 자료를 변환시키는 시스템의 한 부분\n-자료 흐름 : 자료의 흐름이나 연관 관계를 표시\n-자료 저장소 \n-단말 : 시스템과 교신하는 외부 개체/ 입출력 데이터를 처리\n \n자료 사전 : 자료 흐름도의 자료를 상세히 정의한 것\n= : 정의   /    +: and    /   () :생략   /   []:or    /   {}(n,m : 중복-m이상 n이하    /    **: 주석\n \n  \n",
                 "요구사항 분석"
             ),

             titleUrl(
                 "CASE : 요구사항을 자동으로 분석하고, 분석 명세서를 기술하도록 개발된 도구\n-SADT : softtech에서 개발\n-SREM : TRW에서 개발\n-PSL/PSA : 미시간 대학\n-TAGS : 통합 자동화 도구\n \nHIPO : \n입력,출력,처리 기능을 표현한 것\n하향식 개발을 위한 문서화 도구\n-가시적 도표\n-총체적 도표\n-세부적 도표\n \n  \n",
                 "요구사항 분석 CASE와 HIPO"
             ),

             titleUrl(
                 "개발자-고객 / 개발자-개발자 사이의 의사소통에 도움을 주는 객체지향 모델링 언어\nOMG에서 표준으로 지정\n3요소 : 사물-관계-다이어그램\n \n사물 :\n-구조 : 클래스,유즈케이스,컴포넌트.노드.... : 개념적,물리적 요소를 표현\n-행동 : 시공간에 따른 행위를 표현 : 상호작용,상태머신\n-그룹 : 패키지\n-주해 : 부가적인 설명이나 제약조건 : 노트\n \n관계 :\n-연관 : 화살표, 양방향-실선 , 다중도표기\n a->b : a가 b를 소유하는 관계 : b는 누구에게 소유되고 있는지 모름\n-집합 : 하나의 사물이 다른 사물에 포함\n a-◇b : a가 b에 포함 / 그러나 a와 b는 독립적으로 존재\n-포함 :포함하는 사물의 변환는 포함된 사물에게 영향을 준다\n a-◆b : b가 없어지면 a가 없어진다/ \n-일반화 :상속\n a-▷b : b가 부모, a가 자식\n-의존 : 짧은 시간 동안만 연관을 유지\na ...>b : a가 영향을 주는 자 , b가 받는자\n-실체화 : 서로를 그룹화 할수 있는 관계\na...>b :  여기서 b는 기능이다 ex) 새 -->날수 있다 \n \n  \n",
                 "UML"
             ),

             titleUrl(
                 "다이어그램 : 사물과 관계를 도형으로 표현\n \n구조적 다이어그램\n-클래스  : 클래스와 클래스 사이의 관계\n-객체 : 특정 시점의 객체와 객체 사이의 관계를 표현 - 럼바우\n-컴포넌트 : 컴포넌트간의 관계나 인터페이스 표현 / 구현단계에서 활용\n-배치 : 물리적 요소들의 위치를 표현 / 구현 단계\n-복합체 구조  : 내부 구조 표현\n-패키지 : 유스케이스나 클래스 등의 모델 요소들을 그룹화한 페키지등의 관계\n \n행위 다이어그램:\n-유즈케이스 : 기능 모델링 작업에 사용  / 액터,사용사례\n-시퀀스 : 객체들이 주고받는 메시지를 표현\n-커뮤니케이션:\n-상태 : 상호작용에 따라 어떻게 변화하는지 표현\n-활동 : 처리의 흐름을 수선에 따라 표현\n-상호작요 개요:\n-타이밍 : 상태 변화와 시간 제약을 명시적으로 표현\n \n스테레오 타입 :\nUML에서 표현하는 기본 기능외에 추가적인 기능을 표현\n<<include>> : extend,interface,exception,constructor....  길러멧 표현\n \n \n  \n \n \n \n",
                 "다이어그램 - 구조적,행위"
             ),

             titleUrl(
                 "기능 모델링 : 유즈케이스/ 액티비티 다이어그램\n \n유스케이스 다이어그램 : 시스템이 갖춰야할 기능을 사용자와 공유하기 위해 그림으로 표현 하는 것 - 사용자 관점에서 표현\n-외부요소와 시스템간의 상호 작용을 확인가능\n-시스템 범위 파악 가능\n구성요소 :\n-시스템 : 사각형\n-액터 : 시스템과 상호 작용하는 모든 외부 요소\n-유스케이스 : 액터에게 제공하는 서비스나 기능\n-관계 : 포함,확장,일반화등  <<>>\n \n \n액티비티 다이어 그램 : 사용자 관점 , 기능을 처리 흐름에 따라 순서대로 표현\n- 유스케이스 안에서 복잡한 처리의 흐름을 표현 가능\n \n구성 요소 : \n-액션, 액티비티 : 타원으로 표시    액션- 더이상 분해할 수 없는 단일 작업 / 액티비티:복수\n-시작 노드 ⚫\n-종료 노드 🔘\n-조건 노드 ◇\n-병합 노드 ◇\n-포크 노드 :둘로 나뉘는 거\n-조인 노드 :하나로 합쳐지는 거\n-스윔라인 : |  액티비티 수행 주체를 구분하는 선\n \n  \n",
                 "다이어그램 유즈케이스,액티비티"
             ),

             titleUrl(
                 "정적 모델링 : 기능을 구현하는 필요한 자료들의 논리적 구조를 표현한 것\n \n클래스 다이어 그램 : 클래스의 속성, 관계표시\n구성요소:\n-클래스 - 3개의 구획으로 이름,속성,오퍼레이션\n-제약조건\n-관계 : 집합,포함,일반화...\n \n연관 클래스 ?: 연관 관계의 두 클래스에 추가적으로 표현해야 할 속성이나 오퍼레이션이 있을때 생성하는 클래스 \ndb에 다대다 관계와 비슷...\n \n \n \n동적 모델링 : 내부 요소들의 상태 변화 과정이나, 상호작용을 표현 / 시퀀스,커뮤니케이션,상태 다이어그램\n \n시퀀스 다이어그램: 시스템이나 객체들이 메시지를 주고 받으며 상호 작용하는 과정을 그림으로 표현\n-객체들의 수행 기간을 확인 가능\n \n구성요소 :\n-액터: 외부 요소\n-객체 : \n-생명선 : 객체 아래쪽에서 점선으로\n-활성 상자 : 객체가 구동되고 있음을 표현\n-메시지 : 상호작용  -> 로 표시\n-객체 소멸 : x로 표시\n-프레임 : 묶어서 표현한 것\n \n \n \n  \n \n",
                 "다이어그램 클래스,시퀀스"
             ),

             titleUrl(
                 "커뮤니케이션 다이어 그램 : 객체들의 상호작용 과정과, 객체간 연관을 그림으로 표현\n-동작에 참여하는 객체들 사이 관계 파악 가능\n-클래스 다이어 그램에서 관계가 잘 표현됬는지 점검 가능\n- 협업 다이어그램이라고 불렸음\n \n구성요소 :\n-액터\n-객체\n-링크 : 실선 - 관계 표현!!!!\n-메시지\n \n클래스 다이어그램과의 가장 큰 차이 : 메시지뿐 아니라 객체들 간의 관계를 표현한다는 것!\n \n \n상태 다이어그램 : 객체들 사이 발생하는 이벤트에 의한 객체들의 상태 변화를 그림으로 표현\n상태 : 객체의 속성값의 변화\n \n구성요소 :\n-상태 : 타원\n-시작상태\n-종료상태\n-상태전환\n-이벤트\n-프레임\n \n \n패키지 다이어그램: 유스케이스,클래스 등의 요소들을 그룹화한 패키지 간의 의존관계를 표현\n구성요소:\n-패키지\n-객체\n-의존관계\n \n  \n",
                 "다이어그램 커뮤니케이션,상태,패키지"
             ),

             titleUrl(
                 ": sw 개발,유지보수에 필요한 수행 방법과 도구를 정리하여 표준화한 것\n \n \n구조적,정보공학,객체지향,컴포넌트 기반, 제품 계열, 애잘일 방법론\n \n구조적 : 요구사항을 파악하여 문서화하는 처리 중심의 방법론\n-분할 정복 원리를 적용\n-타당성 검토->계획->요구사항->설계->구현->시범->운용/유지보수\n-옛날에 많이 쓰였다\n \n정보공학 : 정형화된 기법들을 통합 및 적용하는 자료 중심의 방법론\n-대규모 시스템을 구축하는데 적합\n-계획->분석->설계->구축\n \n객체지향:sw위기 해결책으로 채택\n구성 : 객체,클래스,메시지\n원칙: 캡슐화,:=정보은닉,추상화,상속성,다형성\n절차 : 분석->설계 -> 구현-> 테스트->인도\n \n캡슐화 - 데이터와 함수를 하나로 묶는 것\n정보은닉 - 다른 객체에게 자신의 정보를 숨김\n \n컴포넌트 기반: 컴포넌트를 조합하여 새로운 애플리케이션을 만드는 방법론\n-재사용이 가능\n-확장성 보장\n-유지보수 비용 최소화\n \n제품 계열: 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론\n-임베디드 sw를 만드는데 적합\n-영역공학 : 핵심 자산을 구현\n-응용공학 : 제품을 구현\n \n  \n",
                 "소프트웨어 개발 방법론"
             ),

             titleUrl(
                 "sw 재사용 : 이미 개발된 sw를 다른 sw개발이나 유지에 사용하는 것\n-합성 중심 : 블록 구성 방법\n-생성 중심 : 패턴 구성 방법 - 명세를 구체화하여 만드는 방법\n \nsw재공학 : 기존 시스템을 이용해 더 나은 시스템을 구축, 새로운 기능을 추가하여 성능을 향상시키는 것\n->품질,생산성,수명 연장 , 오류감소\n=> 유지보수의 생산성을 향상시킨다\n \nCASE: sw 개발 과정에서 사용되는 과정 전체 또는 일부를 sw를 사용하여 자동화하는 것\nComputer Aided Software Engineering\n- sw생명주기 전 단계의 연결 , 다양한 sw 개발 모형 지원 , 그래픽 지원\n \n \n  \n \n \n",
                 "sw공학의 발전적 추세"
             ),

             titleUrl(
                 "비용 결정 요소\n-프로젝트 요소 : sw종류,규모, 신뢰도\n-자원 요소 : 인적,하드웨어,소프트웨어 자원\n-생산성 요소 : 개발자 능력,개발 기간\n \n \n하향식 기법 : 과거 유사 경험을 바탕으로 전문 지식이 많은 개발자들이 참여한 회의를 통해 비용을 산정\n-전문가 감정 기법 : 경험이 많은 두 명 이상의 전문가에게 의소하는 기법, 가장 편리함, 주관적\n-델파이 기법 : 전문가의 주관적 편견을 보완하기 위해 많은 전문가의 의견을 종합하여 산정하는 기법\n \n \n \n상향식 기법 : 세부적인 작업 단위별로 비용을 산정 후 집계하여 전체 비용을 산정하는 방법\n-LOC : 코드 라인 수의 비관치,낙관치,기대치를 측정\n-개발 단계별 인월수 기법 : LOC를 보완 , 기능을 구현하는데 필요한 노력을 산정\n \n \n \n \n \n  \n \n",
                 "비용 산정 기법"
             ),

             titleUrl(
                 " : 상향식 비용 산정 기법중 하나 , 개발 비용 산정의 자동화를 목표 \n \n-COCOMO : LOC로 규모를 예측후, sw종류에 따라 다르게 책정되는 비용 산정 방정식에 대입 , 보헴이 제안함\n 조직형 : 중소규모 sw,\n 반분리형 : 컴파일러,인터프리터 개발에 적합\n 내장형 : 초대형 규모, 실시간 처리 시스템, 미사일 개발 등...\n 종류 :\n  기본형 : sw크기와 개발 유형을 이용해 비용 산정\n  중간형 : 기본형 + 4가지 특성 (제품,컴퓨터,개발 요원,프로젝트)\n  발전형 : sw환경과 구성 요소가 정의되어 있어야 한다\n \n-Putnam모형 : sw 생명주기 전 과정 동안에 사용될 노력의 분포를 예상하는 모형\n대형 프로젝트의 노력 분포 산정에 이용\n \n \n-기능 점수 모형: sw 기능을 증대시키는 요인별로 가중치 부여\n기능 증대 요인 : 입출력,명령어,데이터파일,인터페이스\n \n비용산정 자동화 추정 도구 : SLIM , ESTIMACS\n \n  \n",
                 "수학적 산정 기법"
             ),

             titleUrl(
                 "WBS : 개발 프로젝트를 여러 개의 작은 관리 단위로 분할 하여 계층적으로 기술한 업무 구조\n \nPERT : 프로그램 평가 및 검토 기술 program evaluation and reivew technique\n전체 작업의 상호 관계를 표시하는 네트워크\n \nCPM : 임계 경로 기법 critical path method\n작업을 나열하고 작업에 필요한 소요 기간을 예측\n임계경로=최장 경로!!\n \n간트 차트 : 작업 일정을 막대 도표를 이용해 표시하는 일정표 , 시간선 차트\n \n \n  \n \n \n \n \n \n",
                 "프로젝트 일정 계획"
             ),

             titleUrl(
                 "어떤 방법론으로 sw를 개발할지 결정하는 것 : 자원,일정,비용,품질,위험등을 파악\n \n프로젝트 관리 : 최소의 비용으로 시스테을 개발하기 위한 전반적인 활동\n-일정,비용,인력,위험,품질\n \n \n \nsw 개발 표준 :  품질 관리에 사용되는 국제 표준\n \n-ISO: 국제 표준화 기구\n \n-CMMI: capability maturity model integration\n업무 능력및 조직의 성숙도를 평가하는 모델\n초기=>관리->정의->정량적 관리->최적화\n \n초기 : 정의된 프로세스가 없음, 작업자의 능력에 따라 성공 여부 결정\n관리 :  규칙화된 프로세스 \n정의 : 표준화된 프로세스\n정량적 관리 : 예측 가능한 프로세스\n최적화 : 지속적 개선 프로세스\n \n \n-SPICE : software process improvement and capability determination\nsw프로세스를 평가 및 개선하는 국제 표준\niso 15504\n \n \n  \n",
                 "sw개발 방법론 결정"
             ),

             titleUrl(
                 ": sw 개발 방법론의 절차,사용기법 등을 수정 및 보완하는 작업\n \n내부적 기준: 요구사항,환경,규모,보유기술\n외부적 기준 : 법,품질 기준\n \n \n \n프레임워크 : 공통적으로 사용되는 구성 요소와 아키텍처를 일반화하여 제공하는 반제품 형태의 sw\n전자정부 / 스프링 / 닷넷\n닷넷 : window프로그램의 개발 및 실행 환경을 제공하는 프레임워크 - CLR이라는 가상머신 상에서 작동\n프레임 워크의 특성 - 모듈화, 재사용성,확장성,제어의 역흐름\n \n  \n \n",
                 "sw 개발 방법론 테일러링 / 프레임 워크"
             ),

             titleUrl(
                 "데이터 전환 : 데이터를 추출하여 변환후 적재하는 일련의 과정\n \n데이터전환 계획서 : 데이터 전환이 필요한 대상을 분석하여 데이터 전환 작업에 필요한 모든 계획을기록하는 문서\n \n데이터 검증 : 원천 시스템의 데이터를 목적 시스테의 데이터로 전환이 정상적으로 수행되는지 확인하는 과정\n-로그 검증 , 응용프로그램 검증 , 값 검증 , 기본 항목 검증(요청된 항목 검증) , 응용 데이터 검증(규칙 바탕으로)\n \n \n \n  \n",
                 "데이터 전환/데이터 검증"
             ),

             titleUrl(
                 "데이터 품질 분석 -> 오류 데이터 측정 -> 데이터 정제\n \n오류 상태 :\n-open : 보고만 되고 분석 x\n-assigned : 분석을 위해 개발자에게 오류를 전달한 상태\n-fixed :  수정한 상태\n-closed: 수정된 오류에 테스트 성공\n-deferred : 수정을 연기한 상태\n-classified :  오류가 아니라고 확인된 상태\n \n \n  \n",
                 "오류 데이터 측정 및 정제"
             ),

             titleUrl(
                 ": 공동으로 사용될 데이터를 중복을 배제하여 통합하고, 저장장치에 저장하여 항상 사용할 수 있도록 운영하는 운영 데이터\n \nDBMS : 사용자의 요구에 따라 정보를 생성,관리해주는 소프트웨어\n-정의\n-조작\n-제어\n \n데이터 독립성 : \n-논리적 : 응용 프로그램과 데이터베이스를 독립 => 데이터의 논리적 구조의 변경=> 응용 프로그램 영향 x\n-물리적 : 디스크를 추가,변경해도 응용 프로그램 영향 x\n \n스키마 :데이터베이스의 구조와 제약조건에 관한 명세를 기술한 것\n-외부 : 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 db의 논리적 구조를 정의한 것\n-개념 : 전체적인 논리적 구조,하나만 존재( 외부가 모여서 개념을 이루나...? )\n-내부 : 물리적 저장장치의 입장에서 본 db 구조\n \n \n  \n",
                 "데이터 베이스 개요"
             ),

             titleUrl(
                 "고려사항 : 무결성, 일관성, 회복, 보안, 효율성, 확장\n \n순서 : \n1. 요구조건 분석 : db가 필요한 요도 파악\n2. 개념적 설계 : 추상적으로 표현하는 과정 =>er다이어그램 \n3. 논리적 설계 : 논리적 자료 구조로 변환 시키는 과정\n4. 물리적 설계 : 논리적 구조로 표현된 데이터 -> 물리적 구조의 데이터로 변환\n5  구현 : 논리적,물리적 설계에서 도출된 db스키마를 파일로 생성하는 과정\n \n  \n",
                 "데이터 베이스 설계"
             ),

             titleUrl(
                 ": 현실 세계의 정보들을 컴퓨터에 표현하기 위해 체계적으로 표현한 개념적 모형\n구성요소 - 개체 속성 관계\n \n-개념적 데이터 모델 : 추상적 개념으로 표현하는 과정 =ER다이어그램\n \n-논리적 데이터 모델 : 개념적 구조를 컴퓨터 세계의 환경에 맞도록 변환하는 과정\n \n-물리적 데이터 모델 \n \n데이터 모델에 표시할 요소 : 구조,연선,제약조건\n \n \n  \n",
                 "데이터 모델의 개념"
             ),

             titleUrl(
                 "-개체 : Entity : 개념이나 정보 단위 같은 현실세계의 대상체 /  속성,타입,인스턴스,세트 로 이루어짐\n \n-속성 : db를 구성하는 가장 작은 논리적 단위    기본/설계/파생\n속성수= degree=차수\n \n-관계 : 개체와 개체 사이의 논리적인 연결\n종속,중복,재귀,배타\n일대일,다대다...\n \n  \n",
                 "데이터 모델의 구성요소"
             ),

             titleUrl(
                 "하나의 개체 내에서 인스턴스를 유일하게 구분할 수 있는 구분자\n모든 개체는 한개 이상의 식별자를 반드시 가져야 한다\n \n주 식별자 : 개체를 대표하는 유일한 식별자\n-유일성,최소성,불변성,존재성\n \n \n보조 식별자 : 주 식별자를 대신하여 식별할 수 있는 속성\n \n내부 식별자 :개체 내에서 스스로 만들어지는 식별자\n외부 식별자 : 다른 개체와의 관계에 의해 외부 개체의 식별자를 가져와 사용\n \n단일 식별자 : 주 식별자가 한가지 속성으로만 구성된 식별자\n복합 식별자 : 주 식별자가 두개 이상의 속성으로 구성된 식별자\n \n원조 식별자 : 본질 식별자\n대리 식별자 : 인조 식별자\n \n후보 식별자 : 인스턴스를 유일하게 식별할 수 있는 속성 또는 속성 집합\n \n \n  \n",
                 "식별자"
             ),

             titleUrl(
                 "entity relation 모델: 현실의 무질서한 데이터를 논리 데이터로 표현하기 위한 방법\n개체,관계,속성으로 표현\n \nㅁ 개체\n◇ 관계\nO 속성\n◎ 다중값 속성\n밑줄 : 기본키 속성\n \n  \n",
                 "er모델"
             ),

             titleUrl(
                 "관계형 db : 2차원적인 표를 이용해 상호 관계를 정의하는 db\n보기편함, 성능 안좋음\n \n튜플 : 각각의 행을 뜻한다 - 튜플수-카디널리티\n속성 : db를 구성하는 가장 작은 논리적 단위 - 디그리=차수\n도메인 : 하나의 속성이 취할 수 있는 원자 값들의 집합 ex) '성별' 속성 값의 도메인은 남자/여자\n \n릴레이션 : 하나의 테이블 인듯..? - 한 릴레이션에 똑같은 튜플이 포함될 수 없다\n \n \n  \n",
                 "관계형 db구조/ 관계형 데이터 모델"
             ),

             titleUrl(
                 "키 : 튜플을 찾거나 정렬할 때 기준이 되는 속성\n \n후보키 : 튜플을 유일하게 식별하기 위해 사용되는 속성들의 집합\n-기본키로 사용할 수 있는 속성들\n-유일성,최소성을 모두 만족\n \n기본키 : 후보키중 선정된 키\n대체키 : 기본키를 제외한 후보키\n슈퍼키 : 속성들의 집합으로 구성된 키 : 최소성을 만족하지 못함\n외래키 : 다른 릴레이션의 기본키를 참조하는 속성, 속성들의 집합\n \n  \n",
                 "관계형 데이터베이스의 제약 조건 - key"
             ),

             titleUrl(
                 "db에 저장된 값과 현실 세계의 실제값이 일치하는 정확성\n \n개체 무결성 : 기본키는 null이면 안되고,중복되면 안된다\n참조 무결성 : 외래키는 null 또는 다른 릴레이션의 기본키다\n도메인 무결성 : 속성 값은 도메인에 속해야 한다\n \n데이터 무결성 강화\n-트리거\n-제약조건\n-애플리케이션\n \n  \n",
                 "관계형 데이터베이스의 제약 조건 - 무결성"
             ),

             titleUrl(
                 "관계 대수 : 정보를 검색하기 위해 어떻게 유도하는가를 기술하는 절차적 언어\nselect o\nproject ㅠ\njoin ><\ndivision ÷\n \n일반 집합 연산자 : U  ŉ  -  x    합/교/차/교차곱\n \n  \n",
                 "관계 대수 및 관계 해석"
             ),

             titleUrl(
                 "이상 : 데이터 중복이 발생하고, 중복으로 인해 문제가 발생하는 현상\n \n삽입,삭제,갱신 이상\n \n함수적 종속 : X의 값에 따라 Y의 값을 결정 할 수 있다면 Y는 X에 종속\nX->Y라고 한다\nX는 결정자 Y는 종속자\n \n  \n",
                 "이상/ 함수적 종속"
             ),

             titleUrl(
                 ": 테이블을 무손실 분해 하는 과정\n \n1정규형 : 모든 속성은 원자 값으로만 되어 있어야 한다\n2정규형 : 기본키에 대해 완전 함수적 종속을 만족하게 만들자\n3정규형 : 이행 함수 종속을 제거하자 =>    a->b , b->c 이면 a->b, a->c로 분해하자\nBCNF : 키가 아닌 값이 키값을 결정하는 것을 제거 하자\n \n \n  \n",
                 "정규화"
             ),

             titleUrl(
                 ": 정규화된 데이터 모델을 의도적으로 통합,중복,분리하여 졍규화 원칙을 위해 하는 행위 \n-성능과 효율이 증가\n-일관성,정합성 저하\n \n테이블 통합 :\n두 테이블이 join되어 사용되는 경우가 많다면 통합한다\n \n테이블 분할 :\n-수평분할:레코드를 기준으로 분할, 사용빈도에 따른 분할\n-수직분할:속성이 너무 많을 경우\n \n중복 테이블 추가 :\n-여러 테이블에서 데이터를 추출해서 사용해야 하는 경우\n-다른 서버에 저장된 테이블을 이용하는 경우\n-집계 테이블 , 진행 테이블 등....\n-조인이 많이 발생하는 경우\n \n  \n",
                 "반정규화"
             ),

             titleUrl(
                 "다양한 객체에 관한 정보를 포함하는 시스템 db\n \n메타데이터 :\n시스템 카탈로그에 저장된 정보\n \n데이터 디렉토리 :\n데이터 사전에 수록된 데이터에 접근하는 데 필요한 정보를 관리 유지하는 시스템\n \n-시스템 카탈로그는 사용자,시스템이 모두 접근 <-> 데이터 디렉토리는 시스템만 접근 가능\n \n \n  \n",
                 "시스템 카탈로그"
             ),

             titleUrl(
                 "테이블 : db의 가장 기본적인 객체\n \n-일반 테이블 : \n-클러스터드 인덱스 테이블 : 기본키나 인덱스로 순서에 따라 저장되는 테이블\n-파티셔닝 테이블 : 대용량 테이블을 작은 논리적 단위인 파티션으로 나눈 테이블\n-외부 테이블 : db내에 객체로 존재하는 외부 파일\n-임시 테이블 : 트랜잭션이 종료되면 삭제되며, 세션 별로 데이터를 저장하고 처리할 수 있는 테이블\n \n \n  \n",
                 "데이터베이스 저장 공간 설계"
             ),

             titleUrl(
                 "트랜잭션 : 논리적 기능을 수행 하기 위한 작업의 단위 / 한꺼번에 모두 수행되어야 하는 일련의 연산들\n \n특성:\n-원자성 : 연산이 전부 반영 되던지, 안되던지\n-일관성 : \n-독립성 : 트랜잭션시 다른 연산이 끼어 들 수 없다\n-지속성 : 성공적인 트랜잭션의 결과는 시스템의 고장에 관계없이 영구적이어야 한다\n \nCRUD 분석 : CRUD매트릭스를 만들어 트랜잭션을 분석하는 것\n \n  \n",
                 "트랜잭션 분석 / CRUD 분석"
             ),

             titleUrl(
                 "인덱스 : 데이터 레코드르 빠르게 접근하기 위해 키:포인터 쌍으로 구성되는 데이터 구조\n \n비트맵 인덱스 : 인덱스 칼럼의 데이터를 Bit로 변환하여 키로 사용\n도메인 인덱스 : 개발자가 인덱스를 직접 만들어 사용하는 것\n클러스터드 인덱스 : 인덱스의 키의 순서에 따라 데이터가 정렬되어 저장되는 방식\n \n \n뷰 : 하나 이상의 기본 테이블로부터 유도된 가상 테이블\n-물리적으로 존재하지 않음\n-create/drop으로 생성삭제\n-논리적 데이터 독립성을 제공\n-데이터 관리를 간단하게 해준다\n-보안이 제공된다\n-독립적인 인덱스를 가질 수 없다\n-뷰에 대한 crud가 제약을 따르게된다\n \n클러스터 : 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법\n-데이터 분포도가 넓을수록 유리하다\n단일 테이블 클러스터링 : 처리 범위가 넓을 때\n다중 테이블 클러스터링 : 조인이 많이 발생 할 때\n \n \n  \n",
                 "인덱스/뷰/클러스터"
             ),

             titleUrl(
                 ":대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것\n-액세스 범위를 줄여 쿼리 성능 향상\n-데이터가 분산 저장됨=> 디스크 성능 향상\n-시스템 장애시 데이터 손상 정도를 최소화\n-데이터 가용성 향상\n-조인 비용 증가\n \n종류\n-범위 분할 : \n-해시 분할 : 특정 파티션에 데이터가 집중되는 단점 보안(범위 분할)\n-조합 분할 : 범위 분할 후 해시 분할\n \n \n  \n \n",
                 "파티션"
             ),

             titleUrl(
                 ": 논리적으로는 하나의 시스템이지만 물리적으로는 네트워크를 통해 연결된 분산된 데이터 베이스\n-데이터 처리나 이용이 많은 지역에 db를 위치시킨다\n \n목표:\n-위치 투명성 : db의 실제 위치를 알 필요 없이 액세스\n-중복 투명성 : 동일 데이터가 중복되어 있더라도, 하나의 데이터만 존재하는 것 처럼 사용\n-병행 투명성 : 다수의 트랜잭션이 다른 트랜잭션에 영향을 주지 않음\n-장애 투명성 : \n \n방법:\n테이블 위치 분산 / 테이블 데이터 분할(수평,수직) / 동일한 분할을 여러 서버에 생성\n \n  \n",
                 "분산 데이터 베이스 설계"
             ),

             titleUrl(
                 "이중화 : db를 복제하여 관리하는 것\n-eager 기법 : 트랜잭션 수행중 데이터 변경이 발생하면 이중화된 모든 db에 즉시 전달 하여 변경 내용 반영\n-lazy 기법 : 트랜잭션이 종료되면 변경 사실을 전달\n \n구성 방법 :\n활동-활동   - 구성이 복잡함\n활동-대기\n \n클러스터링 : 두대 이상의 서버를 하나의 서버처럼 운영하는 기술\n-고가용성 : 하나의 서버가 장애발생 -> 다른 서버가 처리\n-병렬처리 : 하나의 작업을 여러 서버가 분산 처리\n \nRTO : 업무 중단 ~ 복구까지 시간\nRPO : 데이터를 복구할 수 있는 기준점\n \n  \n",
                 "데이터 베이스 이중화 / 서버 클러스터링"
             ),

             titleUrl(
                 "권한이 없는 사용자가 액세스 하는 것을 금지\n \n-암호화 : 개인키/공개키\n-접근 통제 : 객체(테이블,칼럼), 주체(사용자) /\n임의 접근 통제(데이터 소유자), 강제 접근통제(시스템), 역할기반 접근통제(중앙 관리자)\n \n보안 모델\n-기밀성,무결성,접근통제 모델\n \n통제 조건:\n-값 종속 통제 : 값에 따라 통제\n- 다중 사용자 통제 : 동시에 접근하는 경우\n- 컨텍스트 기반 통제 : 시간,네트워크 주소,경로 등\n \n \n \n   \n",
                 "데이터 베이스 보안"
             ),

             titleUrl(
                 "로그 파일 : db의 처리내용이나 상태변화를 모두 기록한 파일\nUNDO : 트랜잭션 완료 전에 시슽템이 파손되면 변경 내용을 취소\nREDO : 트랜잭션 완료 후에는 저장매체에 기록되어 있지 않으므로 트랜잭션 내용을 다시 실행해야 한다\n \n \n물리백업 : db파일을 백업\n- 속도가 빠름\n- 원인 파악및 해결이 어려움\n \n논리 백업 :\n-db내 논리적 객체들을 백업\n-원인 파악 및 해결이 쉬움\n-백업 시간이 많이 소요\n \n \n   \n",
                 "데이터베이스 백업"
             ),

             titleUrl(
                 ": 대용량의 데이터를 저장하기 위해 서버와 저장장치를 연결하는 기술\n \n-DAS: direct attached storage\n서버와 저장장치를 케이블로 직접 연결\n외장하드가 포함됨\n비용 저렴\n다른 서버가 접근 못함\n공유 못함\n확장성이 떨어짐\n \n-NAS : network attached storage\n네트워크를 통해 연결\n공유 가능\n유연함\n확장성 뛰어남\n \n-SAN : storage area network\n서버와 저장장치를 연결하는 전용 네트워크를 구성하는 방식\n광케이블 사용\n \n \n   \n",
                 "스토리지"
             ),

             titleUrl(
                 "엔티티->테이블\n속성->카럼\n주 식별자->기본키\n \n모델 품질 기준:\n정확성,완전성,준거성,최신성,일관성,활용성\n \n \n   \n",
                 "논리 데이터 모델의 변환 / 물리 데이터 모델 품질 검토"
             ),

             titleUrl(
                 ":저장고간의 효율성과 실행시간 단축을 위해 사용한다\n \n-선형\n스택,큐,배열,연결리스트\n배열 : 크기와 타입이 동일한 자료들이 순서대로 나열된 자료의 집합\n \n \n비선형\n트리,그래프\n그래프 : 정점,간선의 두 집합으로 이루어진 자료구조\n트리 : 사이클 없는 그래프\n \n   \n",
                 "자료 구조"
             ),

             titleUrl(
                 "트리 : 정점(노드),선분을 이용하여 사이클을 이루지 않도록 구성한 그래프\n차수 : 각 노드에서 뻗어 나온 가지의 수\n트리의 차수 : 가장 큰 차수\n단말노드 : 리프노드 : 자식 노드가 없는 노드 : 차수가 0인 노드\n조상노드 : 임의의 노드에서 근노드 까지의 경로상 모든 노드\n \n이진 트리 : 차수가 2 이하인 노드들로 구성된 트리\n트리 운행법:\npre 전위:root->left->right\nin 중위:left->root->right\npost 후위:left->right->root\n \nx=a/b*(c+d)+e\nprefix     =x+*/ab+cde\n:연산자를 괄효의 앞으로 옮긴다 \n \npostfix    xab/cd+*e+=\n:연산자를 괄호의 뒤로 옮긴다\n \n   \n",
                 "트리/이진트리"
             ),

             titleUrl(
                 "삽입정렬: n^2/ n^2\n-이미 순서화된 파일에 새로운 하나의 레코드를 삽입시킬 때 사용\n- n=1부터 1씩 깍으며 들어갈 위치를 찾자\n85624 -> 58624 -> 56824 -> 25684 -> 24568\n \n선택정렬 : n^2/n^2\n-최속값을 찾아 맨앞으로 두자\n-맨앞의 값을 인덱스 1씩 증가시키며 비교,교환을 끝까지 하는 식\n첫번째 시행 : 85624 -> 58624 -> 28654\n최종 : 85624 -> 28654 -> 24865 -> 24586 ->24568\n \n버블 정렬 : n^2/n^2\n- n=0부터 1씩 올리면 끝까지 인접한 값을 비교 교환\n첫번째 시행 : 85624 -> 58624 -> 56824 ->56284 -> 56248\n최종 : 85624 -> 56248 ->52468 ->24568 \n=>최댓값을 맨 끝으로 보내기 \n \n쉘 정렬: 삽입 정렬 확장 \n퀵정렬 : 키를 기준으로 서브파일을 분해 시키는 정렬 방식 nlogn / n^2\n힙정렬 : 전이진 트리를 이용한 정렬 (complete binary tree)  nlogn/nlogn\n합병 졍렬 : 이미 정렬된 두개의 파일을 합병하는 정렬 방식 : nlogn/nlogn\n기수 정렬 : 큐를 이용해 자릿수 별로 정열하는 방식 : d*n/d*n\n \n \n \n \n   \n",
                 "정렬"
             ),

             titleUrl(
                 "송-수신 모듈과 중계 모듈간의 연계를 구현한 것\n구성요소-\n송신 모듈 : 전송 데이터 생성,변환\n수신 모듈 : 수진 데이터 정제, db에 저장\n연계데이터\n중계시스템 : 송수신 시스템이 위치한 네트워크가 서로 다른 경우 설치\n네트워크\n \n연계 데이터 식별 및 표준화 절차\n연계 범위 및 항목 정의 -> 연계 코드 변환 및 매핑 => 연계 데이터 식별자 추가 => 연계 데이터 표현 방법 정의 -> 연계 정의서\n \n연계 데이터 생성 -> 코드 매핑 -> 인터페이스테이블 새성 -> 연계 서버/송수신 어댑터 -> 전송 -> db반영\n \n \n전송구간 암호화 / 데이터 암호화\n \n   \n",
                 "통합 구현"
             ),

             titleUrl(
                 ":특수한 목적을 갖는 마크업 언어를 만드는 마크업 언어\n \nSOAP : 네트워크상에서 XML을 교환 하기 위한 통신 규약 simple object access protocol\nRESTApi : SOAP을 대체하며, 웹 서비스 api의 집합\n \nWSDL : web service description language : 웹 서비스와 관련된 프로토콜등을 기술하고 게시하기 위한 언어\n-XML로 작성된다\n \n \n연계테스트 : 연계 시스템과 연계시스템 구성요소가 정상적으로 동작하는지 확인\n테스트 케이스 작성 -> 테스트 환경 구축 -> 테스트 수행 -> 결과 검증\n \n \n   \n",
                 "xml / 연계테스트"
             ),

             titleUrl(
                 "하드웨어 : 서버와 클라이언트\n-클라이언트 : 개인 pc, 스마트폰\n-서버 : 웹서버, was, db 서버 , 파일 서버\n \n소프트웨어 : os, dbms\n \n \n \nsw 아키텍처 : sw를 구성한느 요소 간의 관계를 표현하는 시스템의 구조\n아키텍처 설계원리\n-모듈화,추상화,단계적 분해 , 정보 은닉(수정,유지보수가 용이)\n \n상위-하위설계 \n \n설계 과정\n설계 목표 설정-> 시스템 타입 결정 -> 아키텍처 패턴 적용 -> 서브시스템 구체화 -> 검토\n \n협약에 의한 설계 : 컴포넌트 설계시 여러 가정을 공유\n \n \n \n   \n",
                 "개발 환경 구축 / sw 아키텍처"
             ),

             titleUrl(
                 "-레이어 패턴 : 시스템을 계층으로 구분하여 구성하는 고전 패턴 : OSI 모델\n \n-클라이언트 서버 패턴 : 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성된 패턴\n \n-파이프 필터 패턴 : 데이터 스트림 절차를 필터로 캡슐화 하여 파잎를 통해 전송하는 패턴\n \n-MVC 패턴 : MVC로 구조화하는 패턴\n \n-마스터 슬레이브 패턴  : 병렬 연결\n \n-피어투 피어 패턴 : \n \n-인터프리터 패턴  : 번역기, 컴파일러.\n \n \n \n   \n",
                 "아키텍처 패턴"
             ),

             titleUrl(
                 "구성요소 \n-객체 : 데이터와 함수를 묶어 놓은 sw 모듈\n-클래스 : 공통된 속성과 연산을 갖는 객체의 집합\n-메시지 : 객체들 간 상호작용에 사용되는 수단, 객체의 동작이나 연산을 일으키는 외부의 요구 사항\n \n캡슐화 : 외부 접근은 제한하기 위해 인터페이스를 제외한 세부 내용을 은닉 하는 것\n \n상속 : 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것\n \n다형성 : 하나의 메시지에 디해 각각의 객체가 고유한 방법으로 응답할 수 있는 능력\n \n연관성 : 두개 이상의 객체들이 상호 참조하는 관계\n-연관화 : 2개 이상 객체가 상호 관련 있음\n-분류화 : 동일한 형의 특성을 갖는 객체들을 모아 구성\n-집단화 : 관련 있는 객체들을 묶어 하나의 상위 객체를 구성\n-일반화 : 공통적인 성질들로 추상화한 상위 객체를 구성\n \n   \n \n \n",
                 "객체 지향"
             ),

             titleUrl(
                 "객체 지향 분석 : 사용자 요구사항과 관련된 객체,속성,연산,관계 등을 정의하여 모델링 하는 작업\n \n럼바우 분석 기법 : 모든 sw구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법 = 객체 모델링 기법\n객체 모델링 -> 동적 모델링 -> 기능 모델링\n객체 다이어 그램 -> 상태 다이어 그램 -> 자료 흐름도\n \ncoad와 yourdon기법 : er다이어 그램으로 객체의 행위 모델링\n \n \n객체 지향 설계 원칙 \n단일 책임 원칙 : 객체는 단 하나의 책임만 가져야 한다\n개방 폐쇄 원칙 : 기존의 코드를 변경하지 않고 기능을 추가할 수 있어야 한다\n리스코프 치환 원칙 : 자식 클래스는 최소한 부모 클래스의 기능은 수행할 수 있어야 한다\n인터페이스 분리 원칙 : 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다\n의존 역전 원칙 : 추상성이 높은 클래스와 의존 관계를 맺어야 한다\n \n \n   \n",
                 "객체 지향 분석 및 설계"
             ),

             titleUrl(
                 "결합도 : 모듈간의 상호 의존하는 정도 \n내용-공통-외부-제어-스탬프-데이터\n내용 쪽으로 가면 결합도가 높아 안좋은 모듈\n \n내용 : 한 모듈이 다른 모듈의 내부 기능및 자료를 직접 참조\n공통 : 공통 데이터 영역을 여러 모듈이 사용\n외부 : 외부 모듈이 어떤 모듈의 자료를 참조   ..? 내용이랑 뭐가 다르지..?\n제어 : 어떤 모듈이 다른 모듈에게 제어 요소를 전달\n스탬프 : 인터페이스로 자료 전달\n자료 \n \n \n \n응집도 : 모듈간 내부 요소들이 서로 관련 있는 정도\n기능-순차-통신-절차-시간적-논리적-우연적\n기능쪽으로 갈수록 응집이 강해서 좋은 모듈\n \n기능 : 모든 기능이 단일 문제와 연관\n순차 : 모듈 내 하나의 활동으로 부터의 결과 데이터를 다음 활동 입력에 사용\n통신 : 동일 입력을 사용해 다른 기능을 수행\n절차적 : 기능을 '순차적으로' 수행할 경우  -   순착적 응집도와 구별\n시간적 : 특정 시간에 처리\n \n \n \n팬인 : 어떤 모듈을 제어하는 모듈의 수   : 높으면 재사용 측면에서 잘 설계된 것\n팬 아웃 : 모듈에 의해 제어되는 모듈의 수 \n \n \nNS차트 : 논리의 기술에 중점을 두고 도형을 이용해 표현하는 방법\n \n \n   \n",
                 "모듈"
             ),

             titleUrl(
                 ": 한가지 동작을 수행하는 기능을 모듈로 구현한 것\n \n단위 테스트 : 모듈이 정해진 기능을 수행하는지 검증\n시스템 수준의 오류를 잡아 낼 수는 없음\n \nIPC :inter process communication\n모듈간 통식 방식을 구현하기 위해 사용되는 인터페이스 집합\n-shared memory(): 공유 메모리 구성후 통신\n-socket() : 네트워크 통신\n-semaphores : 공유 자원에 대한 접근 제어\npipes and named pipes : 선입선출 방식으로 통신\nmessage queueing : 메시지 전달\n \n \n테스트 케이스 \n식별자 , 테스트 항목 , 입력 명세 , 출력 명세 , 환경 설정 , 특수 절차 , 의존성 기술\n \n   \n",
                 "단위 모듈"
             ),

             titleUrl(
                 ": 여러 프로그램에서 공통으로 사용할 수 있는 모듈\n \n정확성,명확성(중의적 해석 x),완전성(구현에 필요한 모든 것 기술),일관성(충돌 x),추적성(출처)\n \n \n재사용 : 이미 개발된 기능들을 재사용하기에 적합하도록 최적화하는 작업\n함수,객체 , 컴포넌트, 어플리케이션 재사용\n \n모듈의 기능은 예측 가능해야 한다\n \n \n   \n",
                 "공통 모듈"
             ),

             titleUrl(
                 ":자료의 분류나 추출을 용이하게 하기위해 사용하는 기호\n \n식별, 분류, 배열, 표준화 , 간소화 기능\n \n코드 종류 :\n순차,블록,10진,그룹 분류 , 연상 , 표의 숫자 , 합성\n \n   \n",
                 "코드"
             ),

             titleUrl(
                 ": 모듈 간의 관계 및 인터페이스를 설계 할 때 참조할 수 있는 전형적인 해결 방식 또는 예제\n \n생성 패턴 : 클래스나 객체의 생성과 참조 과정을 정의\n \n-추상 팩토리 : 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 연관,의존함 \n-빌더 : 객체 생성\n-팩토리 메서드 : 객체 생성을 서브 클래스에서 처리 - 캡슐화 == 가상 생성자 패턴\n-프로토타입 : 원본 객체를 복제하는 방법으로 객체 생성\n-싱글톤 : 클래스의 인스턴스가 하나임을 보장, 객체를 어디서든 참조할수 있지만, 동시에 참조는 불가\n \n \n구조 패턴 :클래스나 객체들을 조합하여 더 큰 구조를 만드는 패턴\n \n-어댑터 : 인터페이스를 다른 클래스가 이용할 수 있도로 변환\n-브리지 : 구현부와 추상 층을 분리-> 독립적으로 확장 가능\n-컴포지트 : 여러 객체를 포함하는 복합객체를 단일 객체 다루듯이 할 수 있음\n-데코레이터 : 객체에 부가적인 기능을 추가\n-퍼싸드 : 서브 클래스 상위에 인터페이스를 구성, wrapper가 필요함\n-플라이웨이트 : 인스턴스를 매번 생성하는 것이 아니고 공유하기 : 메모리 절약\n-프록시 : 접근이 어려운 객체 사이 인터페이스 역할을 수행\n \n \n행위 패턴 : 클래스난 객체가 상호작용하는 방법이나 책임 분배 방법을 정의\n \n-책임 연쇄 : 요청을 처리할 수 있는 객체가 둘이상 일때 , 하나가 처리 못하면 다른 객체가 처리하도록\n-커맨드 : 요청에 필요한 정보를 로그에 남기는 패턴\n-인터프리터 : 문법 표현을 정의하는 패턴\n-반복자 : 접근이 많은 객체에 동일한 인터페이스를 사용하도록 하는 패턴\n-중재자 : 수 많은 상호작용을 캡슐화하여 객체로 만든다\n-메멘토 : 특정 시점의 객체상태를 객체화시켜 해당 시점으로 돌릴 수 있는 기능\n-옵저버 : 객체의 상태 변형 -> 상속된 다른 객체에 변화된 상태 전달\n-상태 : 객체 상태에 따라 동작을 다르게 처리\n-전략 : 동일 알고리즘을 캡슐화 하여 졍의\n-템플릿 메서드 : 공통된 내용을 상위 클래스에서 정의\n-방문자 : 각 클래스의 처리기능을 별도의 클래스로 구성\n \n   \n",
                 "디자인 패턴"
             ),

             titleUrl(
                 "통합 개발 환경 IDE: 개발에 필요한 다양한 툴을 하나의 인터페이스로 통합하여 제공하는 환경\n \n빌드도구 : 소스코드 파일들을 컴퓨터에서 실행할 수 있는 제품 소프트웨어로 변환하는 과정 또는 결과물\nAnt : another neat tool : 아파치 , 자바프로젝트 공식 빌드 도구, 정해진 표준이 없다\nMaven : 아파치에서 Ant대안으로 개발 , 의존성을 설정하여 라이브러리 관리, 규칙과 표준이 존재\nGradle : Ant와 Maven을 보완하여 개발, Groovy 기반 빌드 스크립트 사용\n \nGroovy? : 자바기반 여러 프로그래밍 언어들의 장점을 모아 만든 동적 객체지향 PL\n \n \n협업도구 : 서로 다른 작업 환경에서 프로젝트를 수행할 수있도록 도와주는 도구\n \n   \n",
                 "개발 지원 도구"
             ),

             titleUrl(
                 "웹 앱의 로직을 구현할 서버 프로그램을 WAS에 탑재하는 것\n \n프레임워크 :\nspring, node, django, ruby on rails, Codeigniter(php)\n \n개발 과정\nDTO/VO\nDAO\nSQL\nService : 사용자 요청에 응답하기 위한 로직을 구현\nController : 사용자 요청에 적절한 서비스 호출\n \n   \n",
                 "서버 개발"
             ),

             titleUrl(
                 "sw 개발 보안  : 보안 취약점을 최소화하여 안전한 sw를 개발하기 위한 보안 활동\n \n세션 통제\n입력 데이터 검증\n보안 기능\n시간 및 상태\n에러처리\n코드 오류\n캡슐화\napi 오용\n \n \napi : 라이브러리를 이용할 수 있도록 규칙 등을 정의해 놓은 인터페이스\n \n   \n",
                 "보안 및 API"
             ),

             titleUrl(
                 ": 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하도록 만든 프로그램\n \n필수 요소\n-대용량 데이터 : 의 처리가 가능\n-자동화 : 사용자 개입 없이 수행\n-견고성 : 중단되는 일 없이\n-인정성/신뢰성 : 오류 발생시 추적 가능\n-성능 : 시간, 충돌\n \n배치 스케줄러 :\n배치 프로그램이 설정된 주기에 맞춰 자동으로 수행되도록 지원해주는 도구\n-스프링 배치 : 로그관리, 추적 ,통계....\n-Quartz : 스프링을 개발되는 프로그램들의 일괄 처리\n-Cron : 리눅스 기본 스케줄러, crontab명령어를 통해 예약\n \ncrontab :\n분 시 일 월 요일(0~6:일~토) 명령어\n- 30 23 25 4,9,11 * /root/com.sh\n4,9,11월 25일 23시 30분에 com.sh실행\n \n0,15,30,45 22 25 3,6,9,12 /batch.sh\n3,6,9,12월 25일 22시 0, 15, 30, 45 분에 실행하겠다\n \n   \n",
                 "배치 프로그램"
             ),

             titleUrl(
                 ": 기업에서 일반적으로 사용하는 여러 기능을 통합하여 제공하는 sw\n \n전용 개발 sw : 모든 기능 요구사항 반영\n \n \n시스템 인터페이스 요구사항 : 개발할 시스템과 외부 시스템을 연동하는데 필요한 인터페이스 \n- 독립적으로 떨어져 있는 시스템들끼리 서로 연동하기 위한 접속 방법\n분석 절차 : 요구사항 선별 -> 관련 자료 준비 -> 분류 -> 분석및 명세 -> 명세서 공유\n \n   \n",
                 "패키지 소프트웨어 / 시스템 인터페이스 요구사항 분석"
             ),

             titleUrl(
                 ":요구사항이 명세서에 완전히 기술 되었는지 검토\n \n검토 계획 -> 검토 -> 베이스 라인 설정\n \n검토 : \n-동료 검토 : 명세서 작성자가 설명, 동료 피드백\n-워크스루 : 명세서 배포 , 회의\n-인스펙션 : 작성자를 제외한 전문가들이 명세 확인\n-CASE 활용 \n \n완전성,일관성,명확성,기능성(what에 중점),검증 가능성(sw가 요구 내용가 일치) , 추적 가능성 , 변경 용이성\n \n   \n \n \n",
                 "인터페이스 요구사항 검증"
             ),

             titleUrl(
                 "내외부 시스템 환경 : ip,port url 등 확인\n내외부 시스템 관리 주체 : 하드웨어 관리자\n \n송수신 데이터 식별 :\n식별대상 데이터 : 송수신 시스템 사이 교환되는 데이터\n-인터페이스 표준 항목, 송수신데이터 , 공통 코드\n \n \n인터페이스 :\n단방향 - 요청만 하고 응답 x\n동기 - 요청하고 응답이 올 때까지 대기\n비동기 - 요처하고 다른작업 수행하다 응답 오면 처리\n \n실시간 : 요청 내용 바로 처리\n지연처리 : 데이터를 모아서...\n배치 : 대량의 데이터 처리\n \n \n \n시스템 연계 기술 :\nDBLink : DB에서 제공하는 객체를 이용\nAPI : 송신 시스템의 DB에서 제공하는 인터페이스\nweb service : 네트워크 정보를 표준화된 서비스 형태로 공유 - WSDL, SOAP등\n \n   \n \n",
                 "인터페이스 시스템 식별"
             ),

             titleUrl(
                 "미들웨어 : 운영체제와 응용 프로그램, 서버와 클라이언트 사이에서 다양한 서비스를 제공하는 sw 종류 -DB  : 클라이언트에서 원격 db와 연결하는 미들웨어 -RPC :  원격 프로세저는 로컬 프로시저 처럼 호출 remote procedure call -MOM : message oriented middleware : 비동기 메시지 전달 -TP Monitor : Transaction Procession Monitor :  트랜잭션 처리 및 감시 -ORB : object request broker: 코바 표준 스펙을 구현한 객체 지향 미들웨어 -WAS : web application server : 동적 컨텐츠를 처리하기 위한 미들웨어\n \n   \n",
                 "미들웨어 솔루션"
             ),

             titleUrl(
                 " : 모듈 간 데이터 교환을 위해 관계를 설정하는 것\n-EAI : enterprise application integration : 기업 내 각종 앱 및 플랫폼 간의 상호 연동이 가능하게 해주는 솔루션 point to point : 앱을 1:1로 연결 , 변경-재사용 어렵 hub and spoke : 중앙 집중형 방식 , 유지보수 좋음 -hub가 중앙 ESB : message bus : 앱 사이에 미들웨어를 두어 처리, 대용량 처리 가능 hybrid :  hub and spoke + message bus : hub사이에 버스를 둔 것 , 데이터 병목 현상 최소화 -ESB : enterprise service bus : 앱 간 연계,데이터변환,웹서비스 지원 등 표준 기반 인터페이스를 제공 앱의 결합도를 약하게 유지 -웹서비스 : 네트워크 정보를 공유하는 기술 , SOA-서비스 지향 아키텍처의 개념을 실현 SOAP : http,smtp등을 활용해 xml 기반 메시지를 교환하는 프로토콜 UDDI : wsdl을 등록하여 서비스와 서비스 제공자를 검색,접근 WSDL : 웹 서비스에 대한 상세 정보를 xml 형식으로 구현 인터페이스 기능 구현 절차 컴포넌트 명세 -> 인터페이스 명세 -> 기능 구현->정형화\n \n   \n",
                 "모듈 연계"
             ),

             titleUrl(
                 "송수신 시스템 간 데이터 교환 및 처리를 실현해 주는 작업\n \n-데이터 통신을 이용한 인터페이스 구현\n수신측에서 파싱하여 해석\njson이나  xml 포맷을 사용\najax로 보냄\n \n-인터페이스 엔티티를 이용한 인터페이스 구현\n인터페이스 테이블에 송신측에서 쓰면 수신 측에서 읽는 ...? \n \njson :  데이터 객체를 속성:값의 형태로 표현하느 개방형 데이터 포맷\najax : 자바 스크립트를 이용, 클라이언트와 서버 간 xml 데이터를 주고 받는 비동기 통신 기술\n \n \n   \n",
                 "인터페이스 구현"
             ),

             titleUrl(
                 ":보안 취약점 분석후 보안 기능 적용\n \n-네트워크 영역:\n암호화\nIPSec : ip 패킷 단위의 데이터 변조 방지\nSSL : secure sockets layer : tcpip계층과 애플리케이션 계층 사이에서 무결성을 보장하는 프로토콜\nS-HTTP : secure hyper text transfer protocol : 클라이언트-서버간 모든 메시지를 암호화\n \n-애플리케이션 영역 : 코드 상의 취약점 보완\n \n-db영역 : 접근 권한, 암호화등...\n \n무결성 검사도구 :\ntripwire , aide  , samhain, claymore .slipwire ,fcheck\n \n \n \n   \n",
                 "인터페이스 보안"
             ),

             titleUrl(
                 "xUnit : java,c++, .net 등 다양한 언어 지원, 단위 테스트 프레임 워크\nSTAF : 크로스 플랫폼에서도 테스트 환경 조성\nFitNesse : 웹 기반 테스트 케이스 지원\nNTAF : STAF + FitNesse = naverNHN\nSelenium : 웹 테스트 프레임 워크\nwatir : ruby를 사용\n \n \n데몬 ? : 특정 상태가 되면 자동을 동작하는 시스템 프로그램\n \n \nAPM : 인터페이스 구현 감시도구\n-스카우터 : os자원 모니터링, 오픈소스\n-제니퍼 : 모든 단계에 걸처 모니터링\n \n   \n",
                 "인터페이스 구현 검증"
             ),

             titleUrl(
                 "CLI : command line interface : 텍스 기반 \nGUI\nNUI : 말과 행동으로 기기 조작\n \n직관성,유효성 (사용자 목적에 완벽히 달성) ,학습성,유연성\n \n \nUI\n구동환경 정의 -> 레이아웃 정의 -> 네비게이션 정의 -> 기능 정의 -> 구성 요소 정의\n                (top,left,content,footer)->(메뉴,버튼,링크) ->             -> 그리드(테이블 도구)\n \n   \n",
                 "사용자 인터페이스"
             ),

             titleUrl(
                 "와이어 프레임 : 페이지에 대한 개략작인 레이아웃이나 뼈대를 설계하는 도구\n \n목업 : 실제 화면과  유사하게 만든 정적인 형태의 모형\n \n스토리 보드 : 와이어프레임에 콘텐츠에 대한 설명, 페이지 간 이동 흐름을 추가한 문서\n \n프로토타입 : 실제 구현된 것처럼 테스트가 가능한 동적인 형태의 모형\n-페이퍼 프로토타입 : 손으로...\n-디지털 프로토타입 : \n \n유스케이스 : 사용자 요구사항을 기능 단위로 표현한 것\n \n \n \n   \n",
                 "UI 설계 도구"
             ),

             titleUrl(
                 "UI 요구사항 작성 순서\n요구사항 확인 -> 정황 시나리오 작성 -> 요구사항 작성\n \n \nISO/IEC 9126 : \n기능성 : 요구사항을 만족하는지\n신뢰성  : 주어진 시간내에 기능을 오류 없이 수행하는지\n사용성 : 사용자가 다시 사용하고 싶은 정도\n효율성  : 얼마나 빠르게 처리할 수 있는지\n유지보수성 : \n이식성 : 얼마나 쉽게 적용할 수 있는지\n \n \nUI 설계\n표지 -> 개정 이력 -> 요구사항 -> 시스템 구조 -> 사이트 맵 -> 프로세스 정의서 -> 화면 설계\n사이트맵 : 사이트에 표시할 컨텐츠를 메뉴 별로 구분하여 설계\n \nUI흐름 설계\n기능 작성 -> 입력 요소 확인 -> 유스케이스 설계 -> 기능 및 양식 확인\n \nUI상세 설계\n요구사항 최종 확인 -> 표지 및 개정 이력 -> UI 구조 -> 메뉴 구조 설계 -> 화면 설계\n \n시나리오 문서 : 다양한 예외 처리 등을 정리한 문서\n완전성 : 누락 x\n일관성 ,이해성 ,가독성, 수정 용이성, 추적용이성\n \n \n \n   \n",
                 "UI / 품질 / 설계"
             ),

             titleUrl(
                 "HCI : human computer interaction \n편리하고 안전하게 사용할 수 있도록 연구하고 개발하는 학문\n최적의 UX를 만드는데 목표\n \nUX : user experience\n사용자가 서비스를 이용하면서 느끼고 생각하게 되는 총체적인 경험\n주관성, 정황성, 총체성\n \n감성공학 : 사용자의 감성에 맞게 설계 및 제작\n \n   \n",
                 "HCI /UX /감성공학"
             ),

             titleUrl(
                 "파레토 법칙 : 앱 20%에 해당 되는 부부넹 80%의 결함이 발견됨\n살충제 패러독스 : 동일 테스트 케이스로는 결함이 발견되지 않음\n정황 의존 : 테스터에 역량, 환경 등에 따라 달라짐\n오류 부재의 궤변 : 결함을 모두 제거 했다해도 요구사항을 만족못하면 품질이 안좋은것\n테스트는 작은 단위부터 해야함\n테스트는 개발자와 관계없는 팀에서 수행해야함\n \n \n   \n",
                 "애플리 케이션 테스트"
             ),

             titleUrl(
                 "정적테스트 : 실행하지 않고 명세를 대상\n-워크스루\n-인스펙션\n-코드 검사\n \n동적 테스트 : 프로그램 실행\n-블랙박스\n-화이트 박스\n \n \n테스트 기반에 따른 테스트 :\n-명세 기반 테스트 : 요구사항에 대한 테스트: 동등 분할, 경계값 분석\n-구조기반 테스트 : 내부 논리 흐름에 따른 테스트 케이스 작성  : 구문 기반,결정기반,조건 기반\n-경험 기반 테스트 : 테스터의 경험을 기반 : 체크리스트, 에러 추정\n \n시각에 따라\n-검증 테스트: 개발자 시각\n-확인 테스트: 사용자 시각\n \n목적에 따라\n-회복 테스트  : 결함을 주어 실패 유도 후 복구 되는지\n- 안전 테스트 : 불법적인 침입을 보호 하는지\n-강도 테스트 : 과도한 정보 부과에도 정상 작동하는지\n-성능테스트 : 효율적인지\n-구조 테스트 : 소스 코드의 복잡도 평가\n-회귀테스트 : 수정된 코드에 결함이 있는지 테스트 \n-병행 테스트 : 기존 sw에 동이한 데이터 입력해 결과가 같은지\n \n   \n",
                 "애플리케이션 테스트의 분류"
             ),

             titleUrl(
                 "화이트 박스 : 원시 코드의 논리적인 모든 경로를 테스트 하여 테스트 케이스를 설계 하는 방법\n모든 문장을 한번 이상 실행\n-기초경로 검사 : 대표적 화이트\n-제어구조 검사 : 조건 검사 , 루프 검사 , 데이터 흐름 검사 \n \n화이트 박스 검증기준 :\n-문장 검증 기준 : 모든 구문 한번 이상 수행했는가\n-분기 검증 기준 : 모든 조건문 이 수행 되었는가\n- 조건 검증 기준 : 조건이 True, False인 경우 다 했는가\n-분기/조건 기준 : \n \n블랙박스 테스트 : 각 기능이 완전히 작동되는 것을 입증, 요구사항 명세를 보면서 수행, 구현된 기능 수행\n-동치 분할 기법 : \n-경계값 분석 : 0~100 이라면 -1 이나 101 넣어보기 \n-원인 효과 그래프 검사 : \n-오류 예측 검사 : 과거 경험이나 감각으로 테스트\n \n \n   \n",
                 "테스트 기법에 따른 애플리케이션 테스트"
             ),

             titleUrl(
                 "V 모델 : 요구사항->분석->설계-> 구현 <-단위테스트<-통합테스트<-시스템 테스트<-인수테스트\n \n단위테스트 : 모듈이나 컴포넌트에 초점을 맞춰 테스트\n통합 테스트 : 단위테스트 완료된 모듈들을 결합하여 하나의 시스템을 완성시키는 과정에서 테스트\n시스템 테스트 : 개발되 sw가 완벽하게 수행하는가\n인수 테스트 : 사용자의 요구사항을 충족했는가 , 알파-베타테스트\n \n \n \n알파 : 개발자앞에서 사용자가 테스트\n베타 : 사용자가 여러 사용자 앞에서 테스트\n \n \n   \n",
                 "개발 단계에 따른 애플리케이션 테스트"
             ),

             titleUrl(
                 ": 단위 테스트가 끝난 모듈을 통합하는 과정에서 오류및 결함을 찾는 테스트 기법\n비점진적 통합 테스트 : 미리 결합된 모듈 전체를 테스트 - 빅뱅 통합 테스트\n점진적 통합 테스트 : 단계적으로 모듈 통합, 하향식,상향식,혼합식\n \n하향식 : 상위 모듈에서 하위 모듈 방향으로 통합\n깊이/넓이 우선 통합\n일시적으로 필요한 조건만을 가지는 시험용 모듈 사용(스텁)\n모듈이 통합 될 때 마다 테스트 실행\n회귀 테스트 실행\n \n상향식 : \n하위 모듈들을 클러스터로 결합\n입 출력을 확인하기 위해 더미모듈 작성 - 드라이버\n클러스터 검사\n드라이버 제거\n \n혼합식 : 샌드위치 동합 테스트 방법 : 하위 수준에서는 상향식 통합, <->\n \n회귀 테스팅 : 통합 테스트로 인해 변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 테스트\n \n   \n",
                 "통합 테스트"
             ),

             titleUrl(
                 "테스트 계획 -> 테스트 분석 및 디자인 -> 데스트 케이스 및 시나리오 작성 -> 테스트 -> 평가 -> 결함 관리\n \n에러 발견 -> 에러 등록 -> 에러 분석 -> 결함 확정 -> 결함 할당 -> 결함 조치 -> 검토\n \n \n테스트 케이스 : 테스트 항목에 대한 명세서\n \n테스트 시나리오 : 테스트 케이스를 적용하는 순서에 따라 여러 개의 테스트 케이스를 묶은 집합\n \n테스트 오라클 : 사전에 정의된 참값을 대입하여 비교하는 기법\n-참 오라클 : 모든 오류 검출 가능 - 모든 테스트케이스의 입력 값에 대해 기대 결과를 제공\n-샘플링 오라클 : 몇몇 케이스에 대해서만 제공\n-추정 오라클 : 몇명 제공 + 몇몇은 추정으로 처리\n-일관성 검사 오라클 : 애플리케이션이 변경이 있을때 검사\n \n \n   \n",
                 "애플리케이션 테스트 프로세스"
             ),

             titleUrl(
                 "정적 분석 도구 : 프로그램을 실행하지 않고 분석하는 도구\n소스 코드에 대한 복잡도나 스타일등 남은 결함 발견에 사용\n \n테스트 실행 도구 : 스크립트 언어를 사용하여 테스트를 실행하는 도구\n스프레드시트에 테스트 데이터를 저장하고 이를 실행\n \n성능 테스트 도구 : 가상의 사용자를 만들어 테스트를 수행함으로써 성능의 목표 달성 여부를 확인\n응답시간,경과시간,처리량등...\n \n테스트 통제 도구 : 테스트 계획, 수행, 결합 관리\n형상관리 도구가 이에 해당\n \n테스트 하네스 도구: 테스트 실행 환경을 실뮬레이션 하여 컴포넌트 및 모듈이 정상적으로 테스트되도록 하는 도구\n테스트 드라이버, 테스트 스텁, 테스트 슈트 , 테스트 케이스 , 테스트 스크립트 , 목 오브젝트\n \n테스트 드라이버 : 하위 모듈을 호출, 결과 도출\n테스트 스텁 : 타 모듈의 기능을 단순히 수행\n테스트 슈트 : 테스트 케이스의 집합\n테스트 스크립트 : 테스트 실행 절차 명세서\n목 오브젝트 : 사용자의 행위를 조건부로 입력해 두어 수행\n \n \n \n테스트 계획 -> 분석 -> 수행 -> 관리\n \n \n   \n",
                 "테스트 자동화 도구"
             ),

             titleUrl(
                 "결함 ? : 개발자가 설계 한 것과 다르게 동작하는 것\n \n결함 관리 프로세스\n결함 관리 계획 ->  결함 기록 -> 결함검토->결함수정->결함재확인->결함상태추적->결함분석 \n \n결함 추적 :\n결함 등록 -> 검토 -> 할당 -> 수정 -> 결함 조치 보류 -> 종료 -> 해제\n보류 : 수정이 불가능해 연기 \n해제 : 결함이 아님으로 판명\n \n결함 심각도 : 전체 시스템에 미치는 치명도\n \n결함 관리 측정 지표\n결함 분포 , 결함 추세 , 결함 에이징\n \n   \n",
                 "결함 관리"
             ),

             titleUrl(
                 "성능 : 최소한의 자원을 사용해 최대한 많은 기능을 신속하게 처리하는 정도\n-처리량\n-응답시간\n-경과시간\n-자원 사용률\n \n성능테스트\n-부하테스트 : 일정 시간 부하를 가해 반응 측정\n-스트레스 테스트 : 과부하 상태에서 어떻게 동작하는지 테스트\n \n \n   \n",
                 "애플리케이션 성능 분석"
             ),

             titleUrl(
                 "시간 복잡도 : 알고리즘을 수행하기 위해 프로세스가 수행하는 연산 횟수를 수치화 한 것\n빅오 : 실행시간이 최악일 때\n빅세타 : 실행시간이 평균일 때\n빅오메가 : 실행 시간이 최상일 때 \n \n빅오 :\nO(1) : 큐의 팝 ,스택의 푸시 등 입력값에 관계 없이 일정하게 문제 해결\nO(logn) : 이진 트리, 이진 검색\nO(n) : for 문\nO(n log n ): 힙정렬, 합병 정렬\nO(n^2) : 삽입정렬,쉘정렬,선택정렬,버블정렬,퀵정렬\nO(2^n) : 피보나치 수열\n \n순환 복잡도 : 논리적인 복잡도를 측정하기 위한 sw의 척도\n화살표 수 - 노드 수 +2\n \n   \n",
                 "복잡도"
             ),

             titleUrl(
                 "클린 코드 : 누구나 쉽게 이해하고, 수정 및 추가 할 수 있는 코드\n스파게티 코드 : 로직이 복잡함\n외계인 코드 : 오래되거나 참고문서나개발자 없어 유지보수가 어려운 코드\n \n클린코드\n-가독성 , 단순성 , 의존성 배제 , 중복성 최소화 , 추상화\n \n   \n",
                 "애플리케이션 성능 개선"
             ),

             titleUrl(
                 "DDL:데이터 정의어 :db를 구축하거나 수정할 목적으로 사용하는 언어\n-create\n-alter\n-drop\n \ncreate schema 대학교  authoriztion 교장;\n=> 교장이 관리하는 대학교 스키마 생성\n \ncreate domain gender char(1) default '여' constraint 성별체크 check(value in ('남','여'));\n도메인 이름이 gender, 기본 여, 값이 남,여인지를 체크 해야함\n \ncreate table student(이름 varchar(15) not null,\n성별 gender,생년월일 date,전공 varchar(15),\nprimary key(이름),\nforeign key(전공) references 학과(학과코드) on delete set null on update cascade ,\nconstraint 제약주기 check(생년월일>='1996-03-29')\n);\n=> 이름이 키, 전공은 학과 테이블의 학과코드를 참조하는 외래 키,\n학과 코드가 삭제시 모든 전공은 null, 학과코드 변경시 관련 전공도 변경됨\n생년월일이 3.29이후 생년월일만 저장 가능\n \ncreate view 김포고객(성명, 전화번호)\nas select 성명,번호 from 고객  where 주소='김포';\n \ncreate unique index 고객변호_id on 고객(고객번호 asc);\n고객번호를 오름차순 정렬하여 고객번호_id라는 이름의 인덱스를 정의 / unique는 선택\n \nalter table student add 냐옹 varchar(15) default '멍멍';\nalter table student alter 냐옹 varchar(35) not null default '냐옹';\nalter table student drop column 냐옹 cascade;\n \ndrop index INDEX cascade/restrict\n \n  \n",
                 "SQL"
             ),

             titleUrl(
                 "DCL: 데이터 보안, 무결성,회복,병행 제어등을 정의하는 데 사용하는 언어\ncommit,rollback,grant,revoke\n \ngrant 권한리스트 on 개체 to 사용자 (with grant option);\nrevoke (grant option for) 권한리스트 on 개체 from 사용자(cascade);\ngrant option : 다른 사용자에게 권한을 주는 행위\n \ncommit : 트랜잭션 수행 후 db에 반영\nrollback : commit 되지 않은 내용들을 취소하고 db복구\nsavepoint : rollback 할 위치를 지정하는 명령어\n \nrollback to svp1\n \n   \n",
                 "SQL"
             ),

             titleUrl(
                 "DML: 데이터를 실질적으로 관리하는데 사용되는 언어\n \nselect, insert, delete 등...\n \ninsert into [a](name,age) select name,age from student where c1=c2;\nupdate [a] set b=c;\n \nwhere name like '김%'   : 김으로 시작하는 이름을 뜻한다\n \n \n   \n",
                 "SQL"
             ),

             titleUrl(
                 "like\n% : 모든 문자를 대표함\n- : 문자 하나를 대표함\n# : 숫자 하나를 대표함\nselect * from A where 이름 like '김%';\n \ndistinct : 중복 제거 출력\nselect distinct name from student;\n \nselect a+'입니다' as A from alphabet;\n \n[에이입니다]\n[비입니다]\n...\n \n헷갈릴만한 것들 : \nselect * from A where b=c and(or) c=d;\n \nselect * from 사원 where 생일 between #01/01/66# and #12/31/74#;\n \nselect top 2 * from 사원  order by 이름 asc , 생일 desc;    - 이름 오름차순 후, 생일 내림차순 결과의 상위 2개출력\n \nselect * rom 사원 where 이름 not in (select 이름 from 인턴);\n \nselect 이름 from 학교 where exists (select 이름 from 취미활동 where 취미활동.이름=반.이름);\n - 취미 활동을 하는 사원들의 부서 검색\n \nselect 사원.이름, 여가활동.경력 from 사원,여가활동 where 여가활동.경력 >=10 and 사원.이름=여가활동.이름;\n \n \n   \n \n",
                 "SQL"
             ),

             titleUrl(
                 "group by:\nselect 부서, count(*) as 사원수 from 월급 where 월급>=100 group by 부서 having count(*)>=2;\n월급이 100 이상인 사원이 2명이상 있는 부서\n \nselect * from 사원 union select * from 인턴;\n사원 테이블과 인턴 테이블을 합쳐서 출력 , 중복 제거\nunion all : 중복 나둠\nintersect : 중복되는 것만 출력\nexcept : 사원에서 인턴 빼기\n \n \n  \n \n",
                 "SQL"
             ),

             titleUrl(
                 "프로시저: sql을 사용하여 작성한 일련의 작업을 저장해두고 월할때 수행하도록 하는 절차형 SQL\n \n실행 :\nexecute 프로시저명 / exec 프로시저명 / call 프로시저명\n제거  : drop procedure 프로시저명\nin/out/\n \n create or replace procedure score_count( sc in int, r out varchar2)\nis\n   a INT;\nbegin\n   select count(*) into a from student;\n   insert into score values(a);\n   commit;\nend;\n \n \n트리거 : 이벤트가 발생할 때 관련 작업이 자동으로 수행되게 하는 절차형 SQL\ncreate or replace trigger 학년정보 before insert on 햑생\nreferencing new as new _table\nfor each row\nwhen (new_table.학년 is null)\n   begin\n      :new_table.학년:='신입생';\n   end;\n \n \n \n함수 : 종료시 단일값만을 반환해야 하는 절차형 SQL이다\n리턴이 꼭 필요\ncreate or replace function findname(idx in int)\nreturn varchar2\nis\n   a varchar2(10);\nbegin\n   select sname into a from product where id=idx;\n   return a;\nend;\n \n \n  \n",
                 "프로시저 / 트리거 / 함수"
             ),

             titleUrl(
                 "if 조건 then\n   실행문장;\nend if;\n \n \nloop\n    실행할 문장 ;\n    exit when 조건;\nend loop;\n \n \n커서 : 쿼리문의 처리 결과가 저장되어 있는 메모리 공간\n%found / %notfound / %rowcount / %isopen 등을 사용\n \n \ndeclare\nname employee.name%type;\ncursor cur(ff int)\nis\nselect name from employee where id>=ff;\n \nbegin\n open cur(20);\n loop\n   fetch cur into pname;\n   exit when cur%notfound;\n   DBMS_OUTPUT.PUT_LINE(pname);\n end loop;\n close cur;\nend;\n \n  \n",
                 "PL/SQL 제어문 / 커서"
             ),

             titleUrl(
                 "접속 기술\n-JDBC: 접속하려는 DBMS의 드라이버가 필요\n-ODBC: 점속하려는 DBMS의 인터페이스 관계 없이 ODBC문장을 이용해 접속 가능 \n- MyBatis : JDBC를 단순화하여 sql mapping 오픈소스 , sql을 분리하여 xml을 만듦\n \n웹 응용 시스템 = 웹 서버 + 웹 어플리케이션 서버\n \n \ndesc 학생;   학생 테이블의 정보를 출력\nshow errors; 절차형 sql 테스트\n \n디버깅 : 기능의 적합성 여부 검증 , 실행을 통해 결과 확인\n \nORM : objec relational mapping\n-객체와 관계형 db의 데이터를 mapping 하는 기술\n-프레임워크가 자동으로 sql을 작성\n \n \n \n  \n",
                 "dbms 접속 / sql 테스트 / ORM"
             ),

             titleUrl(
                 "옵티마이저 : sql이 효율적으로 수행되도록 최적의 경로를 찾아주는 모듈\n-RBO : rule based optimizer : 예측 쉬움, 개발자에 의존\n-CBO : cost based optimizer : 예측 어렵, 비용 산출이 정확\n \n \n  \n",
                 "쿼리 성능 최적화"
             ),

             titleUrl(
                 "SDLC : sw development life cycle\n \n요구사항  분석 -> 설계 -> 구현 -> 테스트 -> 유지보수\n \n개발 보안 요소- 3대요소 + 2개더\n-기밀성 : 인가된 사용자만 접근 허용\n-무결성 : 인가된 사용자만 수정 가능\n-가용성 : 인가된 사용자만 사용 가능\n-인증 : 합법적인 사용자인지 확인\n-부인 방지 : 송수신 증거를 제공\n \n시큐어 코딩 : 보안 요소들을 고려하며 코딩하는 것\n \n \n세션: 서버와 클라이언트의 연결\n \n \n  \n \n",
                 "secure SDLC"
             ),

             titleUrl(
                 "sql injection : 웹 응용 프로그램에 sql을 삽입하여 db 데이터를 유출 및 변조, 권한 우회\nxss : 웹 페이지에 악의적인 스크립트를 삽입하여 비정상적인 기능 수행 : html태그등..\n경로 조작 및 자원 삽입 : 데이터 입출력 경로 조작 - 서버 자원 수정,삭제\n운영체제 명령어 삽입 : 외부 입력값으로 시스템 명령어를 실행\n파일 업로드 : 악의적인 명령어가 포함된 스크리브 파일 업로드\nurl 자동 접속 : 입력 값으로 url을 받는 경우 위험\n메모리 오버 플로 : 할당된 메모리 범위를 넘어선 위치에 자료를 읽거나 쓸때 발생\n \n보안 약점 :\n적절한 인증 없이 중요기능 허용\n부적절한 인가\n잘못된 권한\n취약한 암호화 알고리즘\n중요 정보 평문 저장및 전송\n하드코드된 암호화 키\n \n \n \n  \n",
                 "보안 약점/ 보안"
             ),

             titleUrl(
                 "TOCTOU 경쟁 조건 : 검사시점과 사용시점을 고려하지 않고 코딩하는 경우 발생 - 동기화 부분\n \n에러처리 보안 약점:\n오류메시지 노출 / 오류 상황 대응 부재 / 부적절한 예외 처리\n \n코드오류 : 형변환, 자원 반환 등에서 발생\n-널포인터 역참조\n-부적절한 자원 해제\n-해제된 자원 사용\n-초기화 되지 않은 변수 사용\n \n스택가드 : 스택에서 발생하는 약점을 막는 기술 - 값이 변경되면 오버플로우로 판단하여 실행을 중단\n \n \n \n  \n",
                 "시간 및 상태 / 에러처리 / 코드 오류"
             ),

             titleUrl(
                 "-잘못된 세션에 의한 정보 노출\n-제거되지 않고 남은 디버그 코드\n-public메서드로 반환 받은 private 배열\n-private배열에 public 데이터 할당\n \nAPI 오용 : DNS lookup에 의존한 보안 결정 : ip주소가 아닌 도메인 주소를 사용할때 취약해짐\n \n \n  \n",
                 "캡슐화/ API -보안"
             ),

             titleUrl(
                 "개인키 암호화 : 동일한 키로 데이터를 암호화하고 복호화하는 암호화 기법 RC4, DES  , SEED(KISA가 개발)\n \n공개키 암호화 : 암호화 할 때 사용하는 키는 공개하고, 복호화 할때의 비밀키는 관리자가 관리 RSA\n \n해시 : 임의 길이의 입력 밧을 고정된 길이의 값이나 키로 변환\n-SHA: NIST에서 개발\n-MD5 : MD4의 대안\n \n \n \n  \n \n \n",
                 "암호 알고리즘"
             ),

             titleUrl(
                 "DoS: 대량의 데이터를 한 서버에 집중적으로 전송함으로서 서버의 정상적인 기능을 방해\n-ping of death : 패킷의 크기를 허용 크기 이상으로 전송-> 네트워크 마비\n-smurfing : 막대한 양의 데이터를 집중적으로 보내 네트워크 마비\n-syn flooding : 3-way-handshake를 중단 -> 서버를 대기 상태로 만듬\n-teardrop : 패킷의 offset값을 변경시켜 재조합시 과부하를 발생 시켜 다운\n-land attack : 송신 ip=수신 ip \n-ddos : 여러 곳에 분산된 공격 지점에서 한 서버에 공격 TFN / TFN2K\n \n스미싱 : 문자를 통해 개인정보를 빼내는 수법\n스피어 피싱 : 일반적인 메일로 위장하여 지속적으로 발송\nbrute force attack : 암호화된 문서의 암호키를 찾기 위해 모든 값 대입\n큐싱 : QR코드를 통해 악성 프로그램 설치\nSQL injection\nXSS : 링크 클릭시 악성 스크립트 실행 , \n스니핑 : 남의 패킷 정보를 도청\n \n좀비 pc  : 서버의 제어를 받아 DDoS 공격에 이용됨\nC&C 서버 : 좀비 pc에 명령을 내리는 서버\n봇넷 : 다수의 감염된 컴퓨터들이 네트웤크로 연결된 형태\n웜 : 네트워크를 통해 연속적으로 자신을 복제 -> 과부하-> 시스템 다운\n제로데이 공격 : 취약점 발견시, 공표되기 전 취약점을 공격\n키로거 : 사용자의 키보드 움직임 탐지\n랜섬웨어 : 내부 파일 암호화\n백도어 : 개발자 편의를 위한 보안제거 통로 활용\n트로이목마 : 정상적인 프로그램에 숨어있다가 실행시 실행됨\n \n \n  \n \n",
                 "서비스 공격 유형"
             ),

             titleUrl(
                 "보안 서버 : 개인정보를 암호화하여 송수신하는 기능을 갖춘 서버\n-SSL인증서를 설치해 송수신하는 기능 가능\n \n인증 : 접근 권한을 검증하는 절차\n-지식 기반 인증 : 사용자가 기억하는 정보 기반-패스워드,패스 프레이즈(문장) , 아이핀(사이버 주민번호)\n-소유 기반 : 신분증,OTP(요청때 마다 새 pw 생성) , 메모리 카드\n-생체기반 : 지문,홍채\n-행위 기반 : 서명, 동작\n-위치 기반 : GPS,IP\n \n \n \n  \n",
                 "서버 인증"
             ),

             titleUrl(
                 "보안 아키텍처 : 보안 요소 및 보안 체계를 식별하고 이들 간의 관계를 정의한 구조\n보안 프레임워크 : 안전한 정보 시스템 환경을 유지하고 보안 수준을 향상시키기 위한 체계\n \n로그 : 시스템 사용에 대한 모든 내역\netc/syslog.conf : 로그 관련 파일들의 저장 위치\n \n",
                 "보안 아키텍처/프레임워크/로그분석"
             ),

             titleUrl(
                 "-방화벽 : 내트워크와 인터넷 간 정보를 선별하는 침입 차단 시스템\n \n-침입 탐지 시스템 IDS-intrusion detection system: 오용(미리 입력한 공격 패턴)/이상(평균 대비 비정상적 행위) 탐지 \n \n-침입 방지 시스템 IPS-intrusion prevention system: 비정상적 트래픽 차단    : 방화벽 + IDS\n \n-데이터 유출 방지 DLP-data loss prevention: \n \n-웹 방화벽 : 웹 서버에 특화된 방화벽\n \n-VPN : 사용자가 마치 자신의 전용 회선을 사용하는 것처럼 해주는 보안 솔루션\n \n-NAC : network access control : 네트워크에 접속하는 pc의 mac주소를 관리\n \n-ESMN : enterprise security management : 로그 및 보안 이벤트 통합 관리\n \n \n취약점 분석 계획 -> 분석 대상 선별 -> 분석 -> 평가\n \n  \n",
                 "보안 솔루션"
             ),

             titleUrl(
                 "입출력:\nC : scanf(\"%d %d\",&a,&b); printf(\"%d\n\" a);\nJAVA : a=scan.nextInt(); System.out.println(a);\n \n헝가리안 표기법 : 변수명 작성 시 변수의 자료형을 알 수 있도록 하는 방법  i_a : int형 a / d_a : double a\n \n배열:\nC: int a[]={1,2,3,4,5}  / char str[]=\"string\"; / \nJAVA :  int a[]={2,3,4,5}; / char str[]=new char[5];\n \n포인터:\nint a=50;\nint *b=&a;\n*b=*b+20;\nprintf(\"%d, %d\n\",a,*b)// 70,70\n \n문자열 출력 예:\nchar*s;\ns=\"ceo\";\nfor(int i=0;i<3;i++){\nprintf(\"%c\",s[i]);//c e o \nprintf(\"%c\",*(s+i));//c e o\nprintf(\"%c\",s+i);}//ceo eo o\n \n \n  \n",
                 "Programming Language1"
             ),

             titleUrl(
                 "함수예:\nfunc(int *p){pritf(\"%d\",p[2])}\na={1,2,3,4,5}\nfunc(a)  //3\nfunc(a+1) //4\n \n상속 형변환 예:\nparent{void show(){sysout(\"parent\")]}\nchild extends parent{void show(){sysout(\"child\")}}\nparent p=new child()\np.show() // child\n \n파이썬 출력 : \na=\"123456\"\nprint(a[:-3]) //123\nprint(a[-3:]) //456\n \n파이썬 set :\nar={'a','b','c'}\nar.add('a') # 변화 없음\nar.update({'b','d'})# ar={'a','b','c','d'}\n \n파이썬 배열 :\nar=[1,2,3,3,4]\nar.count(3) # 2\nar.extend([5,6])#1,2,3,3,4,5,6 \nsort() : 기본 오름차순 1,2,3,4,5....\n \n  \n",
                 "Programminng Language2"
             ),

             titleUrl(
                 "절차적 pl :일련의 처리 절차를 정해진 문법에 따라 순서대로 기술하는 언어\nALGOL(C의 모체), FORTRAN(과학 기술 계산용) , COBOL(division으로 구성)\n \n객체 지향 pl :  객체들을 조립해서 프로그램을 작성하는 기법\nJAVA C++ Smalltalk(최초 GUI/1세대 객체지향)\n \n스크립트 언어 : HTML 문서 안에 직접 프로그래밍 언어를 삽입하여 사용하는 언어\n서버용 - 서버에서 해석되어 실행된 후 결과만 클라이언트로 보냄 : ASP, JSP, PHP, PYTHON\n클라이언트용 - 클라이언트의 웹 브라우저에서 해석되어 실행됨 : JS \n \nJS : 클래스 없음, 변수 선언 없음, \nASP :active server page : ms에서 만들었음\nJSP : java server page \n파이썬 : 객체 지향 가능 , 대화형 인터프리터 언어, 플랫폼에 독립적\n쉘 스크립트 : 유닉스/리눅스 계열의 쉘 명령어들의 조합으로 구성됨\nBasic : 절차지향 대화형 인터프리터 언어\n \n \n선언형 언어 : 프로그램이 수행해야 할 문제를 기술하는 언어 - LISP, PROLOG\n-목표를 명시하지만, 알고리즘은 명시하지 않음\n-함수형 언어 : 재귀호출이 많이 이용됨, LISP\n-논리형 언어 : 반복문,선택문을 사용하지 않음, PROLOG\n \n명령형 언어 : 문제를 해결하기 위한 방법을 기술하는 언어- FORTRAN C COBOL JAVA\n \n \n \n  \n",
                 "Programming Language3"
             ),

             titleUrl(
                 "라이브러리 : 자주 사용하는 함수나 데이터들을 미리 만들어 모아 놓은 집합체\nC : #include<stdio.h>\n-stdio : 데이터 입출력\n-stdlib : 자료형 반환,메모리 할당\n \nJAVA : imort java.util\n-util : 날짜 , 난수\n-io :  파일 입출력\n \npython : import random\nos : 운영체제와 상호작용\n \n \n예외처리\ntry{} catch(예외 객체){처리 코드} finally{예외 처리 여부와 상관없이 실행}\n \n \n  \n",
                 "라이브러리/ 예외처리"
             ),

             titleUrl(
                 "운영체제 : 컴퓨터 시스템의 자원들을 효율적으로 관리, 컴퓨터를 효과적으로 사용할 수 있도록 환경을 제공하는 sw\n목적 : \n-처리 능력 향상 : 일정 시간 내 처리하는 일의 양\n-반환 시간 단축 : 작업을 의뢰한 시간부터 처리가 완료될때 까지의 시간\n-사용 가능도 향상 : 시스템을 즉시 사용 가능한 정도\n-신뢰도 향상 : 주어진 문제를 정확히 해결하는 정도\n \nwindows : ms에서 개발\n-GUI제공\n-선점형 멀티태스킹 : \n-PnP : plug and play : 프린터,사운드 등의 하드웨어를 설치 시 , 필요한 시스템 환경을 자동으로 구성\n-OLE : object linking and embedding : 여러 프로그램에서 작성된 문자나 그림을 자유롭게 연결,삽입\n-Single-user : 한 사람만이 독점해서 사용함\n \nUnix : 벨,MIT에서 공동 개발\n-시분할 시스템\n-대화식 os\n-C로 작성됨\n-Tree 구조의 파일 시스템\n-Multi user, Multi tasking 지원\n-커널 : 프로그램과 하드웨어 간의 인터페이스 역할 , os의 전반적 처리 담당\n-쉘 : 명령어 해석기 \n-유틸리티 프로그램 : 일반 사용자가 작성한 프로그램을 처리 : 컴파일러,에디터,디버거\n \nLinux : 리누스 토발즈 개발\n-Unix와 완벽 호환\n-다양한 플랫폼에 설치 가능\n \nMacOS : UNIX 기반, 애플 개발\n \nAndroid : 구글 개발\n-리눅스 커널 기반\n \niOS  : UNIX 기반, 애플 개발\n-타사 제품은 iOS 탑재 불가\n \n \n  \n",
                 "운영체제"
             ),

             titleUrl(
                 "반입 전략 : fetch\n-프로그램이나 데이터를 언제 주기억 장치에 적재할 것인지 결정\n-요구 반입 : 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재하는 방법\n-예상 반입 : 미리 적재\n \n배치 전략 : placement\n-주기억장치의 어디에 위치 시킬 것인지 결정\n-first fit : 최초 적합 : 데이터가 들어갈 수 있는 크기의 빈 영역 중 첫번째 영역에 배치\n-best fit : 최적 적합 : 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 작게 남기는 영역에 배치\n-worst fit : 최악 적합 : 빈 영역 중에서 단편화를 가장 많이 남기는 영역에 배치\n \n교체 전략 : replacement\n-이미 사용되고 있는 영역 중에서 어느 영역을 교체할 것인지 \n \n  \n",
                 "운영체제- 기억장치 관리"
             ),

             titleUrl(
                 "주기억 장치 할당\n-연속 할당 기법\n     -단일 분할 할당 기법\n한순간에는 한명의 사용자만이 사용자 영역을 사용하는 기법\n           -오버레이 : 주기억 장치보다 큰 사용자 프로그램을 실행하기 위한 기법\n           -스와핑 : 하나의 프로그램 전체를 주기억장치에 할당, 필요시 교체\n \n     -다중 분할 할당 기법\n            -정적 할당 기법 : 고정된 크기로 영역을 분할\n            -동적 할당 기법 : 필요한 만큼의 크기로 영역 분할 => 단편화 줄임\n \n-분산 할당 기법(가장 기억장치의 내용을 주기억장치에 할당)\n    -페이징 기법\n프로그램과 주기억장치의 영역을 동일한 크기로 나눈후, 주기억장치에 적재\n외부 단편화 발생 x , 내부 단편화 o\n \n    -세그멘테이션 기법\n다양한 크기의 논리적인 단위로 나눈후 주기억 장치에 적재\n외부 단편화 발생 , 내부 x\n \n가상기억장치 : 보조기억장치의 일부를 주기억 장치처럼 사용하는 것  \n \n   \n",
                 "주기억 장치 할당 기법"
             ),

             titleUrl(
                 ": 페이지 부재 발생시, 어떤 페이지 프레임을 선택해 교체할 것인지 결정\n페이지 부재 : 페이지 프레임에 참조 페이지가 들어 있지 않다면 부재 발생\n \n- 최적 교체 :OPT : optimal replacement\n앞으로 가장 오랫동안 사용하지 않을 페이지를 교체\n가장 효율적인 알고리즘\n \n-FIFO : first in first out \n가장 먼저 들어와서 가장 오래 있었던 페이지 교체\n \n-LRU : least recently used\n최근에 가장 오랫동안 사용하지 않은 페이지 교체\n \n-LFU : least frequently used\n사용 빈도가 가장 적은 페이지를 교체\n \n-NUR : not used recently :=LRU과 비슷\n최근에 사용하지 않은 페이지를 교체\n \n-SCR : second chance replacement :\n가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체 방지 - FIFO 방지\n \n   \n",
                 "페이지 교체 알고리즘"
             ),

             titleUrl(
                 "페이지 크기가 작을 경우 : 단편화가 감소함, 주기억장치로 이동시키는 시간효율이 좋음 , 매핑 속도는 늦음, 전체적 입출력 시간은 늘어남\n클 경우 : 매핑 속도가 빠름, 전체적인 입출력 효율 증가 , 단편화 증가\n \nlocality : 국소성,지역성 - 프로세스가 실행되는 동안 주기억장치를 참조할 때 이부 페이지만 집중적으로 참조하는 성질\n-시간 구역성 : 프로세스 실행 시 하나의 페이지를 일정 시간 동안 집중적으로 액세스\n-공간 구역성 : 일정 위치 페이지 집중 액세스\n \n워킹 셋 : 일정 시간동안 자주 참조하는 페이지들의 집합\n스래싱 : 프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상 - 잦은 페이지 부재등이 원인\n \n   \n \n   \n \n \n",
                 "가상 기억 장치 관리사항"
             ),

             titleUrl(
                 "프로세스 : 실행중인 프로그램 / 비동기적 행위를 일으키는 주체 \nPCB : process control block : 운영체제가 프로세스에 대한 중요한 정보를 저장해 놓은 곳\n프로세스가 생성될 때 고유 pcb가 생성되고, 완료되면 제거된다\n현재 상태 , 포인터 , 고유 식별자 , 우선순위, cpu정보, 주기억장치 관리 정보 , 입출력 상태, 계정 정보를 가진다\n \nready : 프로세스가 프로세서를 할당받기 위해 기다리는 상태\nrun :  준비 상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태\nwait/block : 입출력이 필요 할때 프로세스를 중단하고, 입출력 처리가 완료될 때까지 대기하는 상태\n \n READY--dispatch-->RUN\nRUB--입출력-->WAIT/BLOCK\nWAIT/BLOCK--wakeup-->READY\n \ndispatch : 프로세스가 프로세서를 할당받아 실행 상태로 전이\nWake up : 입출력 작업이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이되는 과정\nSpooling : 상대적으로 느린 입출력 처리를 보완하기 위해 입출력 데이터를 나중에 한꺼번에 디스크에 저장하는 과정\n \nThread : 시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위 / 경량프로세스\n \n   \n",
                 "프로세스"
             ),

             titleUrl(
                 ": 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업\n \n목적:\n공정성 / 처리율 증가 / cpu이용률 증가 / 우선순위 제도 / 오버헤드,응답시간,반환시간,대기 시간 최소화 / 균형 있는 자원 사용 / 무한 연기 회피\n \n \n비선점 스케줄링: 이미 할당된 cpu를 다른 프로세스가 강제로 빼앗아 사용 할 수 없는 스케줄링\n-FCFS : first come first sevice\n준비상태 큐에 도착한 순서에 따라 차례로 cpu 할당\n \n-SJF : shortest job first - 가장 적은 평균 대기시간\n준비 상태 큐에서 실행 시간이 가장 짧은 프로세스에게 먼저 cpu 할당\n \n-HRN : hightest response-ratio next\n대기 시간과 서비스 시간을 이용하는 기법\n우선순위=(대기+서비스)/서비스\n문제에서는 실행시간과 대기시간이 주어질것.!\n \n선점 : 우선순위가 높은 프로세스가 cpu를 강제로 빼앗아 사용할 수 있는 스케줄링\n-Round Robin\n-SRT\n \n   \n",
                 "스케줄링"
             ),

             titleUrl(
                 ": 시스템 소프트웨어의 동작에 영향을 미치는 동적인 값들의 모임\n-상속됨\n-시스템 환경변수 : 시스템 전반에 적용\n-사용자 환경변수 : 계정 내에서만 적용\n \n윈도우\n-%alluserprofile% / %appdata% / %path% / %programfiles% / %systemdrive% / %systemroot% / %tmp% / %userdomain%\n \n리눅스\n\$pwd / \$home / \$path /\$display / set,env,setenv,printenv\n \n   \n",
                 "환경 변수"
             ),

             titleUrl(
                 "Windows\ndir  : 현 폴더위치\ncopy abc.txt g     : abc.txt를 g 파일로 복사\ndel abc.txt\ntype abc.txt     : abc.txt내용 표시\nren abc.txt cde.txt  : 이름 바꾸기\nmd g : g 폴더 만들기\ncd : 이동\ncls : 화면 내용을 지움\nattrib +r abc.txt   : 읽기전용으로 변경    r,a,s,h  읽기,저장,시스템,숨김\nfind \"123\" abc.txt : 123이 표함된 문자열 찾기\nchkdsk : 현재 드라이브 상태 점검\nformat d:   : d드라이브 초기화\nmove a.txt g : g로 이동\n \nLinux\ncat abc.txt : 내용 보기\n \nchmod u=rwx abc.txt : user에게 rwx권한을 준다\nchmod 775 batch.sh : 소유자-그룹-타사용자 순서 읽기-쓰기-실행 순서\n \nchown m abc.txt : 파일 소유자를 m으로 변경\ncp a.txt b.txt : a를 b로 복사\nrm a.txt : 삭제\nfind a.txt : 찾기\nfsck /dev/s : /dev/s에 모든 파일 검사\nkill 1234 : pid 1234를 종료\nfork : 새 프로세스 생성\nkillall a : a이름의 프로세스 모드 종료\nps : 실행중인 프로세스 확인\ntop : 프로세스와 메모리 현황 표시\nwho :  접속해 있는 사용자 표시\n \n \n \n   \n",
                 "os 기본 명령어"
             ),

             titleUrl(
                 ":tcp/ip 기반 광범위 통신망\n \nip : 모든 컴퓨터 자원을 구분하기 위한 고유주소\n \n서브네팅 : 할당된 네트워크 주소를 여러 작은 네트워크로 나누어 사용\n \nIPv6 : \n-IPv4와 호환 가능\n-128비트 주소 사용  (ipv4 : 32)\n-패킷 크기에 제한 x\n-16진후 표현\n-유니캐스트 : 단일 송신자 : 단일 수신자 간의 통신\n-멀티캐스트 : 단일 : 다중\n-애니캐스트 : 단일 : 가장 가까운 단일\n \nflsm 변환\n200.1.1.0/24    10개 패킷으로 나누기\n1010 0000     : (10을 이진수 , 남은비트 4) => 16이 하나의 네트워크\n200.1.1.(0~15) / 200.1.1.(16~31) / ....\n \n \n도메인 : IP주소를 문자로 표현\nDNS : 도메인을 IP로 변환\n \n \n   \n",
                 "인터넷"
             ),

             titleUrl(
                 ": ISO에서 제안한 통신 규약\n \n물리계층: 리피터,허브\n \n데이터 링크 계층 : 랜카드,브리지,스위치\n송수신 측의 속도 차이 해결 가능- 흐름제어\n프레임 동기화\n링크 설정,유지,종료 담당\n \n \n네트워크 계층 :라우터\n연결 설정,유지,해제\n \n전송 계층 : 게이트웨이\n하위3계층, 상위3계층 사이 인터페이스\nend to end 투명한 데이터 전송 가능\n \n세션 계층 :\n송수신 측 간의 관련성 유지 및 대화 제어\n \n표현 계층 :\n응용 계층으로 부터 받은 데이터(세션에서)를 세션 층(응용층으로)으로 보내기전 통신에 적당한 형태로 변환, \n \n응용 계층 : 사용자가 OSI환경에 접근할 수있도록 서비스를 제공\n \n   \n",
                 "osi 모델"
             ),

             titleUrl(
                 "네트워크 인터페이스 카드 : 컴퓨터와 네트워크를 연결\n \n허브 : 컴퓨터들을 연결하는 장치 + 리피터 역할\n \n리피터 : 수신한 신호를 재생시키거나 출력 전압을 높여 젼송하는 장치 - 물리\n \n브리지 : lan 과 lan을 연결/ lan과 컴퓨터 그룹을 연결 , 서브넷 구성 , 트래픽 병목현상 해결\n \n스위치 :  브리지와 같이 연결하여 더 큰 LAN을 만드는 장치 , 하드웨어 기반, 서로 다른 전송 속도 제어 - 데이터\n \n라우터 : 브리지와 같이 연결 + 데이터 전송의 최적 경로를 선택 - 네트워크\n \n게이트웨이 : 프로토콜 구조가 다른 네트워크를 연결하는 장치 , \n \n \n   \n",
                 "네트워크 관련 장비"
             ),

             titleUrl(
                 "프로토콜 : 데이터 교환을 원활하게 수행 할 수 있도록 표준화시켜 놓은 통신 규약\n요소 : 구문/의미/시간\n \ntcp/ip : 서로 다른 기종의 컴퓨터들이 데이터를 주고받을 수 있도록 하는 표준 프로토콜\ntcp : 전송계층 , 신뢰성 o  , 연결형 서비스\nip : 네트워크 계층 , 비연결형 서비스, 데이터그램 기반 \n \n응용계층(응용,표현,세션) : http,DNS,FTP\n전송계층(전송) : TCP,UDP,RTCP\n인터넷계층(네트워크) : IP,RARP,ARP\n네트워크 계층(데이터,물리) : IEEE802, Ethernet\n \n \nFTP : 원격 파일 전송 프로토콜\nSMTP : 전자 우편을 교환하는 서비스\nTELNET : 원격 접속\nSNMP : 네트워크 관리\nDNS : 도메인을 IP로 변환\nHTTP : html문서를 송수신 하기위한 표준 프로토콜\nTCP : 양방향 연결, 가상 회선 연결 제공 , 신뢰성 o \nUDP : 비연결형 서비스 , 속도 빠름 , 신뢰x \nRTCP : 세션에 주기적으로 제어정보를 전송\n \nIP :  internet protocal : 신뢰x \nICMP : 통신중 발생하는 오류 처리 \nIGMP : 멀티캐스트 그룹 유지\nARP : 호스트 ip주소를 mac주소로 바꿈\nRARP : mac주소를 ip주소로 바꿈\n \nEthernet : CSMA/CD 방식 LAN\nIEEE 802 : LAN을 위한 표준 프로토콜\n \n   \n",
                 "tcp/ip"
             ),

             titleUrl(
                 "IoT : 다양한 사물들을 인터넷으로 연결\nM2M : machin to machine : 무선통신\n모바일 켬퓨팅 : 이동하며 접속\n클라우드 컴퓨팅 : 컴퓨팅 자원을 중앙 컴퓨터에 두고 어디서나 인터넷을 통해 작업 가능한 가상환경\n그리드 컴퓨팅 : 여러 컴퓨터를 하나의 고성능 컴퓨터처럼\n모바일 클라우딩  컴퓨팅 : \n인터 클라우드 컴퓨팅 : 여러 클라우드 서비스 사용\n메시 네트워크 : 대규모 디바이스 네트워크 생성\n와이선 : 저전력 장거리 통신\nNDN : named data networking : ip망 대체\nNGN : 차세대 통신망\nSDN : software defined network :  사용자가 네트워크를 가상화하고 제어하여 관리하는 네트워크\nNFC : 고주파 근거리 무선 통신 기술\nUWB : 저전력으로 많은양의 데이터를 전송\n피코넷 : 여러 통신장치가 블루투스 기술을 이용해 통신망을 형성하는 무선 네트워크 기술\nWBAN : 웨어러블이나 몸에 심는 형태의 기기를 연결\nGIS : 지리적 자료를 제공\nUSN : 각종 세서로 수집한 정보를 무선으로 수집, RFID부착\nSON : 스스로 망을 구축하는 네트워크\n애드 혹 네트워크 : 모바일 호스트 만을 이용해 구성한 네트워크\n네트워크 스라이싱 : 물리적인 코어 네트워크를 독립된 다수의 가상 네트워크로 분리\nBLE : 저전력 블루투스\n파장분할 다중화 : 광섬유를 이용한 통신 기술\n소프트웨어 정의 데이터 센서 : SDDC : 모든 자원을 가상화하여 조작\n개방형 링크드 데이터 : 웹상에 공개된 연계 데이터\n \n   \n",
                 "네트워크 신기술"
             ),

             titleUrl(
                 "네트워크 : 두대 이상의 컴퓨터를 연결하여 자원을 공유하는 것\n \n성형 : 중앙 집중식 네트워크 , 단말이 고장 나더라도 영향 x , 중앙 고장나면 큰일 , 추가제거가 쉬움\n \n링형 : 추가제거 어렵, 단방향,양방향 전송 가능 \n \n버스형 : 한개의 회선에 여러 단말장치가 연결, 추가제거 쉬움 , 신뢰성 o, 기밀성x , \n \n계층형 : 일정 지역 단말 장치까지 하나의 통신 회선으로 연결, 트리형태 , 분산처리 시스템 구성 , \n \n망형 : 모든 컴퓨터가 서로 연결 \n \n네트워크 분류\nLAN : 거리가 짧아, 전송 속도 빠름, 버스형이나 링형\nWAN : 국가 간 연결 , 통신 속도 느림, 에러 발생률 높음 , 근거리 통신망으로 연결후  각 근거리 통신망을 연결하는 방식\n \n802.11 : 무선 LAN 규약 , 2mbps\n802.11a - 54mbps\n11b : 11mbps\n11e : mac 계층 수정 가능\n11g : 54mbps\n11n : 600mbps\n \n \nNAT : network address translation\nip주소에 대량의 가상 사설 ip 주소를 할당 및 연결\n \n   \n",
                 "네트워크 구축"
             ),

             titleUrl(
                 " : LAN과 LAN을 연결해 더 큰 LAN을 만드는 장치\nL2,3,4,7 : 각 OSI 2,3,4,7 층에 해당\n \n스위칭 :\n-store and forwarding : 데이터를 모두 받은 후 스위칭하는 방식\n-cut  through : 데이터의 목적지 주소 확인후 바로 스위치\n-fragment free : 두개 합친거\n \n백본 스위치 : 모든 패킷이 지나는 네트워크 중심에 배치\n \n액세스 계층 : 최초로 연결되는 지점\n디스트리뷰션 계층 : 액세스 계층의 통신을 집약해서 전송\n코어 계층 : 백본 계층\n \n   \n",
                 "스위치"
             ),

             titleUrl(
                 "경로제어 : 전송 경로 중에서 최적 패킷 교환 경로를 결정하는 기능\nIGP : interior gateway protocol \n-RIP : routing information protocol : 최단 경로 탐색-bellman ford알고리즘 , 최대홉 15로 제한, 30초마다 모든 라우터에 알림\n-OSPF : open shortest path first protocol : 대규모 , 다익스트라 알고리즘 , 정보 변화시에만 알림 \n \nEGP : exterior gate way protocol : 게이트웨이 간의 라우팅 \nBGP : bordor gateway protocol : \n \n \n트래픽 제어 : 전송되는 패킷의 흐름 또는 양을 조절\n-흐름 제어 : 송수신측 사이에 전송되는 패킷의 양이나 속도 규제\n    -stop and wait : 수신 측의 확인 신호를 받은 후 다음 패킷 전송, 한번에 하나의 패킷만 전송 가능\n    -sliding window : 확인 신호로 송신 데이터 양 조절, 여러패킷 전송 가능 , 확인 신호 없이 미리 정해진 패킷 수 만큼 전송하기도 한다 \n \n-폭주제어  : 네트워크 내에 패킷 수를 조절 = overflow 방지\n    -slow start : 조금씩 보냄, 빨라짐\n    -혼잡 회피 : 윈도우 크기를 1씩 증가시켜 혼잡 예방\n \n \n   \n",
                 "경로 제어 / 트래픽 제어"
             ),

             titleUrl(
                 "뉴럴링크 : 테슬라, 뇌와 컴퓨터 결합\n \n딥러닝 : 인간의 두뇌를 모델로 만든 인공 신경망\n \n블록체인 : P2P네트워크를 이용해 온라인 금융 거래 정보를 온라인 네트워크 참여자의 디지털 장비에 분산 저장\n \n해시 : 임의의 길이의 입력 데이터나 메시지를 고정된 길이의 값이나 키로 변환\n \n그레이웨어 : 악의적이지 않은 sw라고 주장해도, 사용자는 악의적일수 있음\n \n매시업 : 웹에서 제공하는 정보 및 서비스를 이용해 새로운 sw나 서비스등을 만드는 기술\n \nRIA : rich internet application - 플래시 애니매이션과 웹 서버 기술을 통합해 기존 html 보다 역동적\n \n시맨틱 웹 : 사람을 대신해 정보를 이해해 가공하여 새로운 정보를 만들어 내는 차세대 지능형 웹\n \n증발품 : 배포 계획은 발표되었으나, 배포되지 않는 sw\n \nSOA : 서비스 단위나 컴포넌트 중심으로 구축하는 정보기술 아키텍처\n \n서비스형 sw : 사용자가 필요로 하는 서비스만 이용할 수 있도록 한 sw\n \nsw 에스크로 : sw 지식재산권을 보호하고 유지보수 할 수 있도록 소스를 제3기관에 보관\n \n디지털 트윈 : 현실속 사물을 sw로 가상화한 모델\n \n \n   \n",
                 "sw 관련 신기술"
             ),

             titleUrl(
                 "고가용성 : 장애 발생시 즉시 다른 시스템으로 대체\n3D printing : 실제 물체 출력\n4D printing : 자가 조립 시스템- 특정 조건이 되면 스스로 형태를 변화시킨다\nRAID : 여러 하드디스크로 디스크 배열을 구성 -> 속도 향상\n4k 해상도 : 고화질\nN-Screen : 서로 다른 단말기에서 동일 콘텐츠 이용\nConpanion Screen := Second Screen : 방송 시청시 방송을 공유 하는등 추가적 기능 수행\nThin Client PC : 하드 디스크 없이 기본적인 메모리만 갖추고 서버와 네트워크로 운용되는 개인용 컴퓨터\nPhablet : 태블릿 기능을 포함한 대화면 스마트폰\nMEMS :  초미세 반도체 제조 기술 -> 초미세 장치\nTrustZone Technology : 일반 구역과 보안 구역을 나누어 관리하는 하드웨어 보안 기술\nM-DISC : 자료를 영구 보관할 수 있는 광 저장장치 , 빛-열-습도등의 요인에 영향 안받음\n멤리스터 : memory + register  ,네번째 전자회로 구성 요소\n \n \nsw 개발 보안:기밀성, 가용성, 무결성\n \n행정 안정부 : sw 개발 보안 정책 총괄 , 관련 법규- 지침- 제도를 정비\nKISA : 정책 및 가이드를 개발 , 기술 지원 , 교육과정을 운영\n \n \n   \n",
                 "HW 신기술 / sw 개발보안"
             ),

             titleUrl(
                 "Secure OS : 보안 기능을 갖춘 커널을 이식하여 보호하는 운영체제\n암호적 분리, 논리적 분리, 시간적 분리, 물리적 분리\n \n참조 모니터 : 보호 대상 객체에 대한 접근통제\n-격리성 : 조작 불가\n-검증가능성\n-완전성 : 우회불가\n \n \nDB신기술\n빅데이터 : 막대한 양의 정형,비정형 데이터\n브로드 데이터 : 소비자와 상호 작용을 통해 생성된 것\n메타 데이터 : 데이터를 정의하고 설명해 주는 데이터\n디지털 아카이빙 : 정보 자원을 장기적으로 보존하는 작업\n하둡 : 오픈 소스 , 분산 컴퓨팅 플랫폼, 여러 컴퓨터들로 가상화된 대형 스토리지 생성, 자바 프레임워크\n맵리듀스 : 대용량 데이터를 분산 처리, 병렬처리 기법\n타조 : 오픈소스 , 하둡기반 데이터 웨어하우스\n데이터 웨어 하우스 : 여러 분산 데이터를 주제별로 통합한 db\n데이터 다이어트 : 데이터를 압축하여 저장\n데이터마이닝 : 데이터의 일정한 패턴을 찾는 기법\nOLAP : 데이터의 통계적인 요약 정보를 분석\n \n   \n",
                 "Secure OS / DB 신기술"
             ),

             titleUrl(
                 "회복 기법:\n-연기 갱신 : 트랜잭션이 완료될때까지 기다리기\n-즉각 갱신 : 트랜잭션이 완료되기 전에 db에 반영\n \n병행 제어: 동시에 실행되는 트랜잭션 간의 상호작용을 제어\n-로킹 : 잠금을 요청하여 상호 배타적으로 데이터 접근\n-타임 스탬프 순서 : 부여된 시간에 따라 작업을 수행\n \n \n   \n",
                 "회복/ 병행제어"
             ),

             titleUrl(
                 ": 서로 다른 프로세스가 점유하고 있는 자원 을 요구하며 무한정 기다리는 현상\n \n상호배제 - 한번에 한 개의 프로세스만이 공유 자원을 사용할 수 있어야함\n점유와 대기 - 최소한 하나의 자원을 점유, 동시에 사용되고 있는 자원을 추가 점유하기 위해 대기\n비선점 - 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 뺏을 수 없음\n환형 대기 \n \n위 4가지가 모두 충족해야 교차상태가 발생\n \n예방 : 위 4가지 조건중 어느 하나를 제거 함으로서 교착상태 예방\n회피 : 은행원 알고리즘 , 다익스트라 , 교착상태 발생시 적당히 피하는 방법\n발견 : 교착상태 탐지\n회복 : 고착상태의 프로세스를 종료하거나 자원을 선점\n \n \n   \n",
                 "교착상태"
             ),

             titleUrl(
                 ": 시스템을 구성하는 데이터 명칭, 정의, 형식,규칙에 대한 원칙을 수립,적용 하는 것\n \n표준화 대상 : 데이터 명칭, 정의, 형식, 규칙\n \n표준의 종류 : 표준 용어, 표준 단어 , 표준 도메인 , 표준 코드\n \n   \n",
                 "데이터 표준화"
             ),

             titleUrl(
                 "소프트웨어 패키징 : 모듈별로 생성한 실행 파일들으 묶어 배포용 설치 파일로 만드는것\n \n패키징 작업 순서\n기능 식별 -> 모듈화 -> 빌드 -> 사용자 환경 분석 -> 패키징 적용 -> 개선 -> 배포\n \n \n릴리즈 노트 : 개발 과정에서 정리된 릴리즈 정보를 고객과 공유하기 위한 문서\n-헤더 : 릴리즈 노트의 이름,버전,리릴즈 날짜, 노트 버전,날짜 등의 내용\n \n릴리즈 노트 작성 순서\n-모듈 식별 -> 릴리즈 정보 확인 -> 노트 개요 작성 -> 영향도 체크 -> 노트 작성 -> 개선 항목 식별\n \n \n   \n",
                 "스포트웨어 패키징/ 릴리즈 노트"
             ),

             titleUrl(
                 ": 저작권자가 배포한 디지털 콘텐츠가 의도한 용도로만 사용되도록 관리 및 보호 하는 기술\n저작권 : 창작자가 가지는 배타적 독점적 권리\n \n클리어링 하우스 : 소비자에 라이선스 발급 / 저작권 사용 권한,키등을 관리\n콘텐츠 제공자 :클리어링 하우스에 라이선스 등록, 분배자에 콘텐츠 등록\n콘텐츠 분배자 : 클리어링 하우스에 라이선스 요청, 소비자에 암호화된 콘텐츠 다운로드\n콘텐츠 소비자 : 클리어링 하우스에 요금 지불\n패키저 : 콘텐츠를 메타데이터와 함께 배포 가능한 형태로 묶어 암호화\nDRM 컨트롤러 : 배포된 컨텐츠의 권한을 통제\n보안 컨테이너 : 콘텐츠 원본을 안전하게\n \n \n   \n",
                 "DRM - 디지털 저작권 관리"
             ),

             titleUrl(
                 "sw 설치 메뉴얼 작성 순서:\n기능 식별 -> UI 분류 -> 설치 파일 확인 -> Uninstall 절차 -> 이상 Case확인 -> 최종 메뉴얼 적용\n \nsw 사용자 메뉴얼 작성 순서:\n기능 식별 -> 사용자 화면 분류 -> 사용자 환경 파일 확인 -> 초기화 절차 확인 -> 이상 Case 확인 -> 최종 메뉴얼 적용\n \n   \n",
                 "소프트웨어 설치 메뉴얼 작성/ 소프트웨어 사용자 메뉴얼 작성"
             ),

             titleUrl(
                 "형상관리 : 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동\n형상 : sw 개발 단계의 각 과정에서 만들어지는 프로그램\n \n저장소 repository: 최신 버전의 파일들과 변경 내역에 대한 정보들이 저장되어 있는 곳\n가져오기 import : 버전 관리가 되고 있지 않은 아무것도 없는 repo 에 처음으로 파일을 복사함\n체크아웃 : 프로그램을 수정하기 위해 repo 에서 파일을 받아옴\n체크인 : 체크 아웃후 수정 완료후에 repo를 갱신함\n커밋: 체크인시 충돌을 알리고 갱신함\n동기화 update : repo의 최신 버전으로 자신의 공간 동기화\n \nsw 버전 등록 과정 : import -> check out -> commit -> update -> diff\n \n   \n",
                 "소프트웨어 버전 등록"
             ),

             titleUrl(
                 "공유 폴더 : 버전 관리 자료가 지역 컴퓨터의 공유 폴더에 저장되어 관리되는 방식\n \n클라이언트/서버 : 버전 관리 자료가 서버에 저장되어 관리\nCVS,SVN\n \n분산 저장소 :버전 관리가 하나의 원격저장소와 개발자의 pc의 지역 저장소에 함께 저장되어 관리되는 방식\nGIT , \n \n \n \nSVN: CVS를 개선, 아파치 발표\nGIT : 리누스 토발즈 개발 , 2개의 저장소(지역,원격) ,\n \n   \n",
                 "소프트웨어 버전 관리도구"
             ),

             titleUrl(
                 "계정 설정하기\ngit config --global user.name \"myname\"\ngit config --global user.email \"myemail@mail.com\"\n \n저장소 만들기:git init\n \n스테이징 영역에 추가:git add a.txt\n \n작업 내역을 지역 저장소에 저장:git commit -m \"message\"\n \n브랜치 생성:git branch newbranch\n \n브랜치 삭제:git branch --d newbranch\n \n브랜치 옮기기:git checkout newbranch\n \n빌드 자동화 도구 : 빌드를 포함하여 테스트 및 배포를 자동화하는 도구(Jenkins,gradle,ant,maven,make)\n-Jenkins : JAVA 기반 오픈소스 , 서버 기반 도구 , \n-Gradle : Groovy 기반 오픈소스 ,\n \n   \n",
                 "GIT/ 빌드 자동화 도구"
             ),


//         titleUrl("/34?category=845992","소프트웨어 생명주기"),
//             titleUrl("/35?category=845992","스크럼 기법"),
//             titleUrl("/36?category=845992","XP"),
//             titleUrl("/37?category=845992","현행 시스템 파악"),
//             titleUrl("/38?category=845992","개발 기술 환경 파악"),
//             titleUrl("/39?category=845992","요구사항 정의"),
//             titleUrl("/40?category=845992","요구사항 개발 프로세스"),
//             titleUrl("/41?category=845992","요구사항 분석"),
//             titleUrl("/43?category=845992","요구사항 분석 CASE와 HIPO"),
//             titleUrl("/44?category=845992","UML"),
//             titleUrl("/45?category=845992","다이어그램 - 구조적,행위"),
//             titleUrl("/46?category=845992","다이어그램 유즈케이스,액티비티"),
//             titleUrl("/47?category=845992","다이어그램 클래스,시퀀스"),
//             titleUrl("/48?category=845992","다이어그램 커뮤니케이션,상태,패키지"),
//             titleUrl("/49?category=845992","소프트웨어 개발 방법론"),
//             titleUrl("/51?category=845992","sw공학의 발전적 추세"),
//             titleUrl("/52?category=845992","비용 산정 기법"),
//             titleUrl("/53?category=845992","수학적 산정 기법"),
//             titleUrl("/54?category=845992","프로젝트 일정 계획"),
//             titleUrl("/55?category=845992","sw개발 방법론 결정"),
//             titleUrl("/56?category=845992","sw 개발 방법론 테일러링 / 프레임 워크"),
//             titleUrl("/58?category=845992","데이터 전환/데이터 검증"),
//             titleUrl("/59?category=845992","오류 데이터 측정 및 정제"),
//             titleUrl("/60?category=845992","데이터 베이스 개요"),
//             titleUrl("/61?category=845992","데이터 베이스 설계"),
//             titleUrl("/62?category=845992","데이터 모델의 개념"),
//             titleUrl("/63?category=845992","데이터 모델의 구성요소"),
//             titleUrl("/64?category=845992","식별자"),
//             titleUrl("/65?category=845992","er모델"),
//             titleUrl("/66?category=845992","관계형 db구조/ 관계형 데이터 모델"),
//             titleUrl("/67?category=845992","관계형 데이터베이스의 제약 조건 - key"),
//             titleUrl("/68?category=845992","관계형 데이터베이스의 제약 조건 - 무결성"),
//             titleUrl("/69?category=845992","관계 대수 및 관계 해석"),
//             titleUrl("/72?category=845992","이상/ 함수적 종속"),
//             titleUrl("/73?category=845992","정규화"),
//             titleUrl("/74?category=845992","반정규화"),
//             titleUrl("/75?category=845992","시스템 카탈로그"),
//             titleUrl("/76?category=845992","데이터베이스 저장 공간 설계"),
//             titleUrl("/80?category=845992","트랜잭션 분석 / CRUD 분석"),
//             titleUrl("/81?category=845992","인덱스/뷰/클러스터"),
//             titleUrl("/82?category=845992","파티션"),
//             titleUrl("/83?category=845992","분산 데이터 베이스 설계"),
//             titleUrl("/84?category=845992","데이터 베이스 이중화 / 서버 클러스터링"),
//             titleUrl("/85?category=845992","데이터 베이스 보안"),
//             titleUrl("/86?category=845992","데이터베이스 백업"),
//             titleUrl("/87?category=845992","스토리지"),
//             titleUrl("/88?category=845992","논리 데이터 모델의 변환 / 물리 데이터 모델 품질 검토"),
//             titleUrl("/89?category=845992","자료 구조"),
//             titleUrl("/90?category=845992","트리/이진트리"),
//             titleUrl("/91?category=845992","정렬"),
//             titleUrl("/92?category=845992","통합 구현"),
//             titleUrl("/93?category=845992","xml / 연계테스트"),
//             titleUrl("/94?category=845992","개발 환경 구축 / sw 아키텍처"),
//             titleUrl("/95?category=845992","아키텍처 패턴"),
//             titleUrl("/96?category=845992","객체 지향"),
//             titleUrl("/97?category=845992","객체 지향 분석 및 설계"),
//             titleUrl("/98?category=845992","모듈"),
//             titleUrl("/99?category=845992","단위 모듈"),
//             titleUrl("/100?category=845992","공통 모듈"),
//             titleUrl("/101?category=845992","코드"),
//             titleUrl("/102?category=845992","디자인 패턴"),
//             titleUrl("/103?category=845992","개발 지원 도구"),
//             titleUrl("/105?category=845992","서버 개발"),
//             titleUrl("/106?category=845992","보안 및 API"),
//             titleUrl("/107?category=845992","배치 프로그램"),
//             titleUrl("/108?category=845992","패키지 소프트웨어 / 시스템 인터페이스 요구사항 분석"),
//             titleUrl("/109?category=845992","인터페이스 요구사항 검증"),
//             titleUrl("/110?category=845992","인터페이스 시스템 식별"),
//             titleUrl("/111?category=845992","미들웨어 솔루션"),
//             titleUrl("/112?category=845992","모듈 연계"),
//             titleUrl("/114?category=845992","인터페이스 구현"),
//             titleUrl("/115?category=845992","인터페이스 보안"),
//             titleUrl("/116?category=845992","인터페이스 구현 검증"),
//             titleUrl("/117?category=845992","사용자 인터페이스"),
//             titleUrl("/118?category=845992","UI 설계 도구"),
//             titleUrl("/119?category=845992","UI / 품질 / 설계"),
//             titleUrl("/120?category=845992","HCI /UX /감성공학"),
//             titleUrl("/121?category=845992","애플리 케이션 테스트"),
//             titleUrl("/122?category=845992","애플리케이션 테스트의 분류"),
//             titleUrl("/123?category=845992","테스트 기법에 따른 애플리케이션 테스트"),
//             titleUrl("/124?category=845992","개발 단계에 따른 애플리케이션 테스트"),
//             titleUrl("/125?category=845992","통합 테스트"),
//             titleUrl("/126?category=845992","애플리케이션 테스트 프로세스"),
//             titleUrl("/127?category=845992","테스트 자동화 도구"),
//             titleUrl("/128?category=845992","결함 관리"),
//             titleUrl("/129?category=845992","애플리케이션 성능 분석"),
//             titleUrl("/130?category=845992","복잡도"),
//             titleUrl("/131?category=845992","애플리케이션 성능 개선"),
//             titleUrl("/134?category=845992","SQL -ddl"),
//             titleUrl("/135?category=845992","SQL -dcl"),
//             titleUrl("/136?category=845992","SQL-dml"),
//             titleUrl("/137?category=845992","DML- select"),
//             titleUrl("/138?category=845992","DML-select"),
//             titleUrl("/139?category=845992","프로시저 / 트리거 / 함수"),
//             titleUrl("/140?category=845992","PL/SQL 제어문 / 커서"),
//             titleUrl("/141?category=845992","dbms 접속 / sql 테스트 / ORM"),
//             titleUrl("/142?category=845992","쿼리 성능 최적화"),
//             titleUrl("/143?category=845992","secure SDLC"),
//             titleUrl("/144?category=845992","보안 약점/ 보안"),
//             titleUrl("/147?category=845992","시간 및 상태 / 에러처리 / 코드 오류"),
//             titleUrl("/148?category=845992","캡슐화/ API -보안"),
//             titleUrl("/149?category=845992","암호 알고리즘"),
//             titleUrl("/150?category=845992","서비스 공격 유형"),
//             titleUrl("/151?category=845992","서버 인증"),
//             titleUrl("/152?category=845992","보안 아키텍처/프레임워크/로그분석"),
//             titleUrl("/153?category=845992","보안 솔루션"),
//             titleUrl("/154?category=845992","Programming Language1"),
//             titleUrl("/156?category=845992","Programminng Language2"),
//             titleUrl("/157?category=845992","Programming Language3"),
//             titleUrl("/158?category=845992","라이브러리/ 예외처리"),
//             titleUrl("/159?category=845992","운영체제"),
//             titleUrl("/160?category=845992","운영체제- 기억장치 관리"),
//             titleUrl("/161?category=845992","주기억 장치 할당 기법"),
//             titleUrl("/162?category=845992","페이지 교체 알고리즘"),
//             titleUrl("/163?category=845992","가상 기억 장치 관리사항"),
//             titleUrl("/164?category=845992","프로세스"),
//             titleUrl("/165?category=845992","스케줄링"),
//             titleUrl("/166?category=845992","환경 변수"),
//             titleUrl("/167?category=845992","os 기본 명령어"),
//             titleUrl("/168?category=845992","인터넷"),
//             titleUrl("/169?category=845992","osi 모델"),
//             titleUrl("/170?category=845992","네트워크 관련 장비"),
//             titleUrl("/171?category=845992","tcp/ip"),
//             titleUrl("/172?category=845992","네트워크 신기술"),
//             titleUrl("/173?category=845992","네트워크 구축"),
//             titleUrl("/174?category=845992","스위치"),
//             titleUrl("/175?category=845992","경로 제어 / 트래픽 제어"),
//             titleUrl("/176?category=845992","sw 관련 신기술"),
//             titleUrl("/177?category=845992","HW 신기술 / sw 개발보안"),
//             titleUrl("/178?category=845992","Secure OS / DB 신기술"),
//             titleUrl("/179?category=845992","회복/ 병행제어"),
//             titleUrl("/180?category=845992","교착상태"),
//             titleUrl("/181?category=845992","데이터 표준화"),
//             titleUrl("/182?category=845992","스포트웨어 패키징/ 릴리즈 노트 "),
//             titleUrl("/183?category=845992","DRM - 디지털 저작권 관리 "),
//             titleUrl("/184?category=845992","소프트웨어 설치 메뉴얼 작성/ 소프트웨어 사용 자 메뉴얼 작성 "),
//             titleUrl("/185?category=845992","소프트웨어 버전 등록 "),
//             titleUrl("/186?category=845992","소프트웨어 버전 관리도구 "),
//             titleUrl("/187?category=845992","GIT/ 빌드 자동화 도구 "),
             titleUrl(
                 "출처:시나공-정보처리기사-실기(김정준, 강윤석,김용갑,김우경,길벗알앤디외)출판사:길벗",
                 "출처:시나공-정보처리기사-실기(김정준, 강윤석,김용갑,김우경,길벗알앤디외)출판사:길벗"
             ),

             )

     }

 }